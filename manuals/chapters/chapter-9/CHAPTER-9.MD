# Chapter 9: Handling errors. / ç¬¬9ç«  ã‚¨ãƒ©ãƒ¼ã®ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
In Motoko, when something doesn't work as expected, there are various ways to show that an error has occurred. Some methods include:  
Motoko ã§ã¯ã€ä½•ã‹ãŒæœŸå¾…é€šã‚Šã«å‹•ã‹ãªã„ã¨ãã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸã“ã¨ã‚’ç¤ºã™ã•ã¾ã–ã¾ãªæ–¹æ³•ãŒã‚ã‚Šã¾ã™ã€‚ã„ãã¤ã‹ã®æ–¹æ³•ã‚’ç´¹ä»‹ã—ã¾ã™ï¼š
- Using the `Result` type.  
- `Result`å‹ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ 
- Throwing error with the `throw` keyword or the `Error` library.
- `throw` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã¾ãŸã¯ `Error` ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ã€ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã™ã‚‹ã€‚
- Trapping the program. 
- ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ãƒˆãƒ©ãƒƒãƒ—ã™ã‚‹ã€‚

In this section we will see different options and learn when to use each one for managing errors effectively.  
ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€ã•ã¾ã–ã¾ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¦‹ã¦ã€ã‚¨ãƒ©ãƒ¼ã‚’åŠ¹æœçš„ã«ç®¡ç†ã™ã‚‹ãŸã‚ã«ãã‚Œãã‚Œã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å­¦ã³ã¾ã™ã€‚
## ğŸš¥ The `Result` type. / `Result` å‹
The `Result` type is extremly useful in Motoko to handle errors, it is defined as a variant type.  
`Result` å‹ã¯ã€Motoko ã§ã¯ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã™ã‚‹ã®ã«éå¸¸ã«ä¾¿åˆ©ã§ã€ãƒãƒªã‚¢ãƒ³ãƒˆå‹ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚
```motoko
type Result<Ok, Err> = {#ok : Ok; #err : Err}
```
With `Ok` and `Err`, you can specify the types to return based on success or failure. For example, when creating a Result type for student graduation:  
`Ok`ã¨`Err`ã§ã¯ã€æˆåŠŸã¾ãŸã¯å¤±æ•—ã«åŸºã¥ã„ã¦è¿”ã™å‹ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€å­¦ç”Ÿã®å’æ¥­ã‚’è¡¨ã™ Result å‹ã‚’ä½œæˆã™ã‚‹å ´åˆï¼š

```motoko
type Score = Nat; // The score of a student. / ç”Ÿå¾’ã®ç‚¹æ•°ã€‚
type ExamFailed = {
    #ScoreTooLow : Nat;     //  The score of the student.  / ç”Ÿå¾’ã®ç‚¹æ•°ã€‚
    #Absent;    //  One reason for not passing an exam. / è©¦é¨“ã«åˆæ ¼ã§ããªã„ç†ç”±ã®ä¸€ã¤ã€‚
    #Cheated;   //  Another reason for not passing an exam. / è©¦é¨“ã«åˆæ ¼ã§ããªã„ã‚‚ã†ä¸€ã¤ã®ç†ç”±ã€‚
};
```
- If a student graduates, their score is returned. The score is of type `Score`, which is an alias for `Nat`.
- å­¦ç”ŸãŒå’æ¥­ã—ãŸå ´åˆã€ãã®ã‚¹ã‚³ã‚¢ãŒè¿”ã•ã‚Œã¾ã™ã€‚ã‚¹ã‚³ã‚¢ã¯ `Score` å‹ã§ã‚ã‚Šã€ã“ã‚Œã¯ `Nat` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚
- If a student fails, a variant indicating the reason for failure is returned. The variant is of type `ExamFailed`.
- å­¦ç”ŸãŒä¸åˆæ ¼ã ã£ãŸå ´åˆã€ä¸åˆæ ¼ã®ç†ç”±ã‚’ç¤ºã™ variant ãŒè¿”ã•ã‚Œã¾ã™ã€‚variant ã¯ `ExamFailed` å‹ã§ã™ã€‚

Now we can use those new types to replace `Ok` and `Err`.  
ã“ã‚Œã§ã€ã“ã‚Œã‚‰ã®æ–°ã—ã„å‹ã‚’ä½¿ã£ã¦ `Ok` ã¨ `Err` ã‚’ç½®ãæ›ãˆã‚‹ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚
```motoko
type ExamResult = Result.Result<Score, ExamFailed>;
```
In cases like our example, using a variant type for `Err` is quite common. It allows for better management of different error types and makes pattern matching easier. This means anyone reviewing the error can better understand its specific cause!  
ã“ã®ä¾‹ã®ã‚ˆã†ãªå ´åˆã€`Err` ã«ãƒãƒªã‚¢ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã¯éå¸¸ã«ä¸€èˆ¬çš„ã§ã™ã€‚ã“ã‚Œã¯ã€ç•°ãªã‚‹ã‚¨ãƒ©ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’ã‚ˆã‚Šã‚ˆãç®¡ç†ã—ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’ã‚ˆã‚Šç°¡å˜ã«ã™ã‚‹ãŸã‚ã§ã™ã€‚ã“ã‚Œã¯ã€ã‚¨ãƒ©ãƒ¼ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã™ã‚‹äººãŒã€ãã®ç‰¹å®šã®åŸå› ã‚’ã‚ˆã‚Šã‚ˆãç†è§£ã§ãã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ï¼
```motoko
func sendMessageToStudent(result : ExamResult) : Text {
    switch(result) {
        case(#ok(score)){
            return ("Congrats ğŸ‰ - you have graduated with a score of : " # Nat.toText(score));
        };
        case(#err(failure)){
            switch(failure){
                (#ScoreTooLow(score)){
                    return ("Unfortunately your score is below requirements. Next time you'll graduate! You had a score of : " # Nat.toText(score));
                };
                case(#Absent){
                    return ("You were absent at the exam. Please schedule another time.");
                };
                case(#Cheated){
                    return("Cheating is a short-term gain that leads to long-term pain");
                };
            };
        };
    };
};
```
### When should I use the Result type? / Result ã‚¿ã‚¤ãƒ—ã¯ã©ã®ã‚ˆã†ãªå ´åˆã«ä½¿ç”¨ã™ã‚Œã°ã‚ˆã„ã§ã™ã‹ï¼Ÿ
Using `Result` to report errors in your API offers a significant benefit: it allows other developers and programs to handle errors predictably. That's why `Result` is often used for expected errors in your program when you want to return a value. `Result` will not impact the normal behavior of the program.  
API ã§ã‚¨ãƒ©ãƒ¼ã‚’å ±å‘Šã™ã‚‹ãŸã‚ã« `Result` ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€ä»–ã®é–‹ç™ºè€…ã‚„ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã‚¨ãƒ©ãƒ¼ã‚’äºˆæ¸¬å¯èƒ½ã«å‡¦ç†ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã¨ã„ã†å¤§ããªãƒ¡ãƒªãƒƒãƒˆãŒã‚ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ å†…ã§äºˆæƒ³ã•ã‚Œã‚‹ã‚¨ãƒ©ãƒ¼ã«å¯¾ã—ã¦ã€å€¤ã‚’è¿”ã—ãŸã„ã¨ãã« `Result` ãŒã‚ˆãä½¿ã‚ã‚Œã¾ã™ã€‚`Result` ãŒãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®æ­£å¸¸ãªå‹•ä½œã«å½±éŸ¿ã‚’ä¸ãˆã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

## ğŸª¤ Trap & assertions / ãƒˆãƒ©ãƒƒãƒ— ã¨ ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
A **trap** is a type of error that occurs during the execution of a message and cannot be resolved. The most common causes of traps are:  
**ãƒˆãƒ©ãƒƒãƒ—** ã¨ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å®Ÿè¡Œä¸­ã«ç™ºç”Ÿã—ã€è§£æ±ºã§ããªã„ã‚¨ãƒ©ãƒ¼ã®ä¸€ç¨®ã§ã™ã€‚ãƒˆãƒ©ãƒƒãƒ—ã®åŸå› ã¨ã—ã¦æœ€ã‚‚ä¸€èˆ¬çš„ãªã‚‚ã®ã¯ã€ä»¥ä¸‹ã®é€šã‚Šã§ã™ï¼š
- Division by zero.
- ã‚¼ãƒ­ã«ã‚ˆã‚‹é™¤ç®—ã€‚
```motoko
let a : Nat = 5;
let b : Nat = 0;
let c = a / b;
```
- Index is out of bounds. 
- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒåœå¤–ã«ãªã£ãŸã€‚
```motoko
let names : [Text] = [];
```
- Assertion failure
```motoko
assert(false);
```
In some situations, it can be useful to trap on purpose, with a defined message.  
çŠ¶æ³ã«ã‚ˆã£ã¦ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ˜ç¢ºã«ã—ãŸä¸Šã§ã€æ„å›³çš„ã«ãƒˆãƒ©ãƒƒãƒ—ã‚’ã‹ã‘ã‚‹ã“ã¨ãŒæœ‰åŠ¹ãªå ´åˆã‚‚ã‚ã‚Šã¾ã™ã€‚

The best way to do so if to use the `Debug.trap()` method from the [Debug library](https://internetcomputer.org/docs/current/motoko/main/base/Debug) which allows you to pass an error message along the `trap`.  
ãã®ãŸã‚ã«ã¯ã€[Debug library](https://internetcomputer.org/docs/current/motoko/main/base/Debug) ã® `Debug.trap()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒä¸€ç•ªã§ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã¯ã€`trap` ã«æ²¿ã£ã¦ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã™ã€‚
```motoko
func trap(errorMessage : Text) : None
```
### Assertions / ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³
Using the `assert` keyword to construct assertions lets you check if a certain condition is met. If the condition inside `assert()` is `false`, the program will stop running. If it's `true`, the program will continue as normal.  
`assert` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ã£ã¦ã‚¢ã‚µãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã™ã‚‹ã¨ã€ã‚ã‚‹æ¡ä»¶ãŒæº€ãŸã•ã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚`assert()` ã®ä¸­ã®æ¡ä»¶ãŒ `false` ã§ã‚ã‚Œã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œã¯åœæ­¢ã—ã¾ã™ã€‚ã‚‚ã— `true` ãªã‚‰ã°ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯é€šå¸¸é€šã‚Šç¶šè¡Œã•ã‚Œã¾ã™ã€‚
```motoko
assert(2 == 1);  // always traps / å¸¸æ™‚ãƒˆãƒ©ãƒƒãƒ—
```
```motoko
assert n % 2 == 0; // traps only when n not even / n ãŒå¶æ•°ã§ãªã„å ´åˆã«ã®ã¿ãƒˆãƒ©ãƒƒãƒ—
```
```motoko
assert(true) // never traps æ±ºã—ã¦ãƒˆãƒ©ãƒƒãƒ—ã•ã‚Œãªã„
```

### When should I use a Trap? / ãƒˆãƒ©ãƒƒãƒ—ã¯ã©ã®ã‚ˆã†ãªå ´åˆã«ä½¿ç”¨ã™ã‚‹ã®ã§ã™ã‹ï¼Ÿ
Traps immediately stop the current task (i.e message) being executed by a canister, but they don't prevent the canister from handling future requests. Traps should be used for unexpected situations. For example, the `unwrap` function below:  
ãƒˆãƒ©ãƒƒãƒ—ã¯ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚ˆã£ã¦å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ç¾åœ¨ã®ã‚¿ã‚¹ã‚¯ï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãªã©ï¼‰ã‚’ç›´ã¡ã«åœæ­¢ã—ã¾ã™ãŒã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒä»Šå¾Œã®è¦æ±‚ã‚’å‡¦ç†ã™ã‚‹ã®ã‚’å¦¨ã’ã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ãƒˆãƒ©ãƒƒãƒ—ã¯äºˆæœŸã›ã¬äº‹æ…‹ã«ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€ä»¥ä¸‹ã® `unwrap` é–¢æ•°ãŒãã†ã§ã™ï¼š
```motoko
/// Unwraps the value of the option.
public func unwrap<T>(option : ?T) : T {
    switch option {
        case (?value)
            value;
        case null
            Debug.trap("Value is null - impossible to unwrap")
    }
};
```
> Traps have a very useful feature: if a function traps, the canister's state will be reverted. This will be discussed further in the context of [inter-canister calls](../chapter-11/CHAPTER-11.MD#commit-point-and-rollbacks).

> ãƒˆãƒ©ãƒƒãƒ—ã«ã¯éå¸¸ã«ä¾¿åˆ©ãªæ©Ÿèƒ½ãŒã‚ã‚Šã€é–¢æ•°ãŒãƒˆãƒ©ãƒƒãƒ—ã—ãŸå ´åˆã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ãƒˆã¯å…ƒã«æˆ»ã‚Šã¾ã™ã€‚ã“ã‚Œã«ã¤ã„ã¦ã¯ã€[inter-canister calls](../chapter-11/CHAPTER-11.MD#commit-point-and-rollbacks) ã®æ–‡è„ˆã§ã•ã‚‰ã«èª¬æ˜ã™ã‚‹äºˆå®šã§ã™ã€‚

## ğŸ”€ Handling asynchronous errors with the `Error` type and try/catch. / éåŒæœŸã‚¨ãƒ©ãƒ¼ã‚’ `Error` å‹ã¨ try/catch ã§ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã€‚
> In this section the term **error** refers specifically to any value of type `Error`.

In Motoko, error handling can be a bit confusing, especially if you are used to error handling in other programming languages. Here are some key points to keep in mind:  
Motoko ã§ã¯ã€ç‰¹ã«ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã«æ…£ã‚Œã¦ã„ã‚‹å ´åˆã€ã‚¨ãƒ©ãƒ¼å‡¦ç†ãŒå°‘ã—æ··ä¹±ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã¯ã€ç•™æ„ã™ã¹ããƒã‚¤ãƒ³ãƒˆã‚’ã„ãã¤ã‹ç´¹ä»‹ã—ã¾ã™ï¼š

- Errors can be thrown using the `throw` keyword.
- Errors can be handled using the `try/catch` pattern.
- An error is of type `Error`, which can also be manipulated using the Error library.
- ã‚¨ãƒ©ãƒ¼ã¯ `throw` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã—ã¦æŠ•ã’ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
- ã‚¨ãƒ©ãƒ¼ã¯ `try/catch` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”¨ã„ã¦ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã§ãã‚‹ã€‚
- ã‚¨ãƒ©ãƒ¼ã¯ `Error` å‹ã§ã‚ã‚Šã€Error ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦æ“ä½œã§ãã‚‹ã€‚

However, error handling in Motoko can only be done in an asynchronous context. This means that you can only throw or catch errors in the body of a shared function.
In this example, we define an actor that contains two functions: `throwErrorSync` and `throwErrorAsync`.  
ã—ã‹ã—ã€Motoko ã®ã‚¨ãƒ©ãƒ¼å‡¦ç†ã¯ã€éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã§ã—ã‹è¡Œãˆã¾ã›ã‚“ã€‚ã¤ã¾ã‚Šã€å…±æœ‰é–¢æ•°ã®ãƒœãƒ‡ã‚£å†…ã§ã—ã‹ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã—ãŸã‚Šã‚­ãƒ£ãƒƒãƒã—ãŸã‚Šã§ããªã„ã®ã§ã™ã€‚
ã“ã®ä¾‹ã§ã¯ã€2ã¤ã®é–¢æ•°ã‚’å«ã‚€ã‚¢ã‚¯ã‚¿ãƒ¼ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ï¼š `throwErrorSync` ã¨ `throwErrorAsync` ã§ã™ã€‚
```motoko
import Error "mo:base/Error";
actor {
  // Misplaced throw / æŠ•ã’é–“é•ãˆ
  func throwErrorSync() : () {
    throw Error.reject("This will not work")
  };

  // Can throw an error in a shared/public function - this error will be consumed by another canister/user calling this function.
  // shared/public é–¢æ•°ã§ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®ã‚¨ãƒ©ãƒ¼ã¯ã€ã“ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™åˆ¥ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼/ãƒ¦ãƒ¼ã‚¶ã«ã‚ˆã£ã¦æ¶ˆè²»ã•ã‚Œã¾ã™ã€‚
  public func throwErrorAsync() : async () {
    throw Error.reject("This will not work")
  };
}
```
> You can see this example [in the Motoko Playground](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=907568632) - note the `misplaced throw` message in the body of `throwErrorSync`.

> ã“ã®ä¾‹ã¯ [Motoko Playground](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=907568632) ã§è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™ - `throwErrorSync` ã®ãƒœãƒ‡ã‚£ã«ã‚ã‚‹ `misplaced throw` ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚

The `try/catch` pattern in Motoko is particularly useful when you are attempting to call another canister and want to handle any possible errors that may occur during the call. This can include situations such as:  
Motoko ã® `try/catch` ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ä»–ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’å‘¼ã³å‡ºãã†ã¨ã—ã¦ã„ã‚‹ã¨ãã«ã€å‘¼ã³å‡ºã—ä¸­ã«ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ãŸã„å ´åˆã«ç‰¹ã«ä¾¿åˆ©ã§ã™ã€‚ã“ã‚Œã«ã¯ã€æ¬¡ã®ã‚ˆã†ãªçŠ¶æ³ãŒå«ã¾ã‚Œã¾ã™ï¼š

- The target canister is not live or cannot be reached.
- å¯¾è±¡ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒç”Ÿãã¦ã„ãªã„ã€ã¾ãŸã¯åˆ°é”ã§ããªã„ã€‚
- The function being called does not exist on the target canister.
- å‘¼ã³å‡ºã•ã‚ŒãŸé–¢æ•°ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ»ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«å­˜åœ¨ã—ãªã„ã€‚
- The function being called traps, either due to a programming error or because it has run out of resources.
- å‘¼ã³å‡ºã•ã‚ŒãŸé–¢æ•°ãŒã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãƒ»ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½¿ã„æœãŸã—ãŸãŸã‚ã«ã€ãƒˆãƒ©ãƒƒãƒ—ã—ãŸã€‚
- The function being called throws an error that needs to be handled.
- å‘¼ã³å‡ºã•ã‚ŒãŸé–¢æ•°ãŒã€å‡¦ç†ã™ã‚‹å¿…è¦ã®ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’ã‚¹ãƒ­ãƒ¼ã—ã¦ã„ã‚‹ã€‚

Assuming this is our canister A - deployed with canister id:  
ã“ã‚ŒãŒã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ A ã§ã‚ã‚‹ã¨ä»®å®šã™ã‚‹ã¨ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ ID ã§ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã‚‹ã“ã¨ã«ãªã‚Šã¾ã™ï¼š 
```motoko
actor {
    public func foo() : async Text {
        return "foo"
    };   
}
```
Assuming this is our canister B  
ã“ã‚ŒãŒç§ãŸã¡ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ B ã§ã‚ã‚‹ã¨ä»®å®šã™ã‚‹ã¨
```motoko
actor {

    let canisterA = actor("xxx") : actor {
        foo : shared () -> async Text;
    };

    public func fooFromCanisterA() : async Text {
        tryÂ {
            let foo = await canisterA.foo()
            return foo;
        } catch (e) {
            return "An error occured when calling canister A".
        };
    };   
}
```
In the provided example, we have two canisters: **Canister A** and **Canister B**.  
ã“ã®ä¾‹ã§ã¯ã€2ã¤ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒã‚ã‚Šã¾ã™ï¼š **ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼A**ã¨**ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼B**ã§ã™ã€‚
- **Canister A** has a single public function `foo` that returns the text "foo". 
- **ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼A**ã«ã¯ã€ãƒ†ã‚­ã‚¹ãƒˆ "foo "ã‚’è¿”ã™å˜ä¸€ã®ãƒ‘ãƒ–ãƒªãƒƒã‚¯é–¢æ•°`foo`ãŒã‚ã‚Šã¾ã™ã€‚
- **Canister B** has a public function `fooFromCanisterA` that attempts to call the `foo` function on **Canister A** using the `try/catch` pattern. If the call to `canisterA.foo()` is successful, the function returns the value of `foo`. If an error occurs during the call, it is caught by the catch block, and the function returns the text `"An error occurred when calling canister A"`.
- **ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼B** ã¯ãƒ‘ãƒ–ãƒªãƒƒã‚¯é–¢æ•° `fooFromCanisterA` ã‚’æŒã£ã¦ãŠã‚Šã€`try/catch` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦ **ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼A** ã® `foo` é–¢æ•°ã‚’å‘¼ã³å‡ºãã†ã¨ã—ã¾ã™ã€‚`canisterA.foo()` ã®å‘¼ã³å‡ºã—ã«æˆåŠŸã™ã‚‹ã¨ã€ã“ã®é–¢æ•°ã¯ `foo` ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚å‘¼ã³å‡ºã—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã€ãã‚Œã¯ catch ãƒ–ãƒ­ãƒƒã‚¯ã«ã‚ˆã£ã¦æ•æ‰ã•ã‚Œã€é–¢æ•°ã¯ `"An error occurred when calling canister A"` ã¨ã„ã†ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿”ã—ã¾ã™ã€‚

This example illustrates how the `try/catch` pattern can be used to handle errors when calling functions on other canisters, ensuring that your program continues to execute gracefully even if an error occurs during the call.  
ã“ã®ä¾‹ã§ã¯ã€`try/catch`ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ç”¨ã—ã¦ã€ä»–ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®é–¢æ•°ã‚’å‘¼ã³å‡ºã™éš›ã®ã‚¨ãƒ©ãƒ¼ã‚’å‡¦ç†ã—ã€å‘¼ã³å‡ºã—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã§ã‚‚ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå„ªé›…ã«å®Ÿè¡Œã•ã‚Œç¶šã‘ã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹æ–¹æ³•ã‚’èª¬æ˜ã—ã¦ã„ã¾ã™ã€‚

## ğŸ¤” Final words / æœ€å¾Œã®è¨€è‘‰
Dealing with all these different situations and ways of handling unexpected issues can be confusing at first, especially when it comes to the `actor` model and asynchronous contexts. But don't stress if you don't get it all right away. The best way to understand it is to get some practice and as you'll encounter different situations your understanding will strengthen!  
ã“ã‚Œã‚‰ã®ç•°ãªã‚‹çŠ¶æ³ã‚„äºˆæœŸã›ã¬å•é¡Œã‚’å‡¦ç†ã™ã‚‹æ–¹æ³•ã‚’æ‰±ã†ã“ã¨ã¯ã€ç‰¹ã« `actor` ãƒ¢ãƒ‡ãƒ«ã‚„éåŒæœŸã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«é–¢ã—ã¦ã¯ã€æœ€åˆã¯æ··ä¹±ã™ã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚ã—ã‹ã—ã€ã™ãã«ã™ã¹ã¦ã‚’ç†è§£ã§ããªãã¦ã‚‚ã‚¹ãƒˆãƒ¬ã‚¹ã‚’æ„Ÿã˜ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ç†è§£ã™ã‚‹ãŸã‚ã®æœ€è‰¯ã®æ–¹æ³•ã¯ã€ç·´ç¿’ã‚’é‡ã­ã‚‹ã“ã¨ã§ã‚ã‚Šã€æ§˜ã€…ãªçŠ¶æ³ã«é­é‡ã™ã‚‹ã“ã¨ã§ç†è§£ãŒæ·±ã¾ã‚Šã¾ã™ï¼