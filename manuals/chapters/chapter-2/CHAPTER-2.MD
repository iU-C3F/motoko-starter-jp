# Chapter 2: Common programming concepts. / ç¬¬2ç« ï¼šä¸€èˆ¬çš„ãªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®æ¦‚å¿µ
## ğŸ“¦ Variables / å¤‰æ•°
A variable is a value that has an arbitrary name, defined by a declaration. <br/>
å¤‰æ•°ã¨ã¯ã€å®£è¨€ã«ã‚ˆã£ã¦å®šç¾©ã•ã‚ŒãŸã€ä»»æ„ã®åå‰ã‚’æŒã¤å€¤ã®ã“ã¨ã§ã™ã€‚<br/>
In Motoko, variables can be declared using either the `let` or `var` keyword, followed by the assignment operator `=`
Motoko ã§ã¯ã€å¤‰æ•°ã¯ `let` ã¾ãŸã¯ `var` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§å®£è¨€ã—ã€ãã®å¾Œã«ä»£å…¥æ¼”ç®—å­ `=` ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚

- Variables declared with `let` are immutable, meaning that their value cannot be changed once they are assigned. 
- `let`ã§å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã¯ã€ä¸€åº¦ä»£å…¥ã•ã‚Œã‚‹ã¨ãã®å€¤ã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãŒã§ããªã„ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚‚ã®ã§ã™ã€‚
```motoko
let n = 1;
```
- Variables declared with `var` are mutable, their value can be reassigned to a new value at any time using the reassignment operator `:=`.
- `var`ã§å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã¯ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã‚ã‚Šã€ãã®å€¤ã¯å†å‰²ã‚Šå½“ã¦æ¼”ç®—å­ `:=` ã‚’ç”¨ã„ã¦ã„ã¤ã§ã‚‚æ–°ã—ã„å€¤ã«å†å‰²ã‚Šå½“ã¦ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```motoko
var n = 1;
n := 2;
```

The syntax convention is to use `lowerCamelCase` for variable names and to use spaces around the `=` sign. Also, a variable declaration ends with a semicolon `;` Whenever you declare a variable don't forget to end the declaration with `;` otherwise Motoko will complain.

æ§‹æ–‡ã®æ±ºã¾ã‚Šã¯ã€å¤‰æ•°åã«ã¯ `lowerCamelCase` ã‚’ä½¿ã„ã€`=` è¨˜å·ã®å‘¨ã‚Šã«ã¯ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ã†ã“ã¨ã§ã™ã€‚ã¾ãŸã€å¤‰æ•°ã®å®£è¨€ã¯ã‚»ãƒŸã‚³ãƒ­ãƒ³ `;` ã§çµ‚ã‚ã‚Šã¾ã™ã€‚å¤‰æ•°ã‚’å®£è¨€ã™ã‚‹ã¨ãã¯ã€å¿…ãš `;` ã§çµ‚ã‚ã‚‰ã›ã‚‹ã“ã¨ã‚’å¿˜ã‚Œãªã„ã§ãã ã•ã„ã€‚

If we try the following code:  
è©¦ã—ã«æ¬¡ã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã¿ã‚‹ã¨ï¼š
```motoko
let n = 1;
n := 2;
```

An attempt is made to reassign a value to an immutable variable - that's why an error will occur. The specific error message will be `type error [M0073], expected mutable assignment target`. This  message indicates that the variable being reassigned is immutable and cannot be changed.

ä¸å¤‰ã®å¤‰æ•°ã«å€¤ã‚’å†ä»£å…¥ã—ã‚ˆã†ã¨ã—ãŸãŸã‚ã€ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚å…·ä½“çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ `type error [M0073], expected mutable assignment target` ã§ã™ã€‚ã“ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ã€å†ä»£å…¥ã•ã‚Œã‚‹å¤‰æ•°ãŒä¸å¤‰ã§ã‚ã‚Šã€å¤‰æ›´ã§ããªã„ã“ã¨ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚

## ğŸ Types / å‹
The **Motoko** language places a strong emphasis on types and is more strict in enforcing them compared to other general-purpose languages like **JavaScript** or **Python**. This strictness serves a purpose, as it helps prevent errors and issues. 

**Motoko** è¨€èªã¯ã€**JavaScript** ã‚„ **Python** ã®ã‚ˆã†ãªä»–ã®æ±ç”¨è¨€èªã¨æ¯”è¼ƒã—ã¦ã€å‹ã‚’é‡è¦–ã—ã€ãã®å¼·åˆ¶ã‚’ã‚ˆã‚Šå³æ ¼ã«è¡Œã£ã¦ã„ã¾ã™ã€‚ã“ã®å³å¯†ã•ã¯ã€ã‚¨ãƒ©ãƒ¼ã‚„å•é¡Œã‚’é˜²ãã¨ã„ã†ç›®çš„ã‚‚ã‚ã‚Šã¾ã™ã€‚

**Motoko** has static types, this means that each variable is assigned a specific type, which is determined before the program runs. The compiler checks each use of the variable to avoid errors that may occur during runtime. <br/>

**Motoko** ã¯é™çš„ãªå‹ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ã€å„å¤‰æ•°ã«ç‰¹å®šã®å‹ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ãŠã‚Šã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒå®Ÿè¡Œã•ã‚Œã‚‹å‰ã«æ±ºå®šã•ã‚Œã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€å®Ÿè¡Œæ™‚ã«ç™ºç”Ÿã™ã‚‹å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’å›é¿ã™ã‚‹ãŸã‚ã«ã€å¤‰æ•°ã®å„ä½¿ç”¨ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚<br/>

To assign a type to a variable we use the `:` symbol, this is called **type annotation**.  
å¤‰æ•°ã«å‹ã‚’å‰²ã‚Šå½“ã¦ã‚‹ã«ã¯ã€`:`ã¨ã„ã†è¨˜å·ã‚’ä½¿ã„ã¾ã™ãŒã€ã“ã‚Œã‚’**å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³**ã¨å‘¼ã³ã¾ã™ã€‚
```motoko
let age : Nat = 20;
let message : Text = "Of all the acts, the most complete is that of building";
let open : Bool = false;
```

You can generally omit the type declaration - the **Motoko** compiler will automatically guess the type to the variable based on the first value that you provide this is called **type inference**.

ä¸€èˆ¬ã«ã€å‹å®£è¨€ã‚’çœç•¥ã§ãã¾ã™ã€‚**Motoko** ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã€æœ€åˆã«æŒ‡å®šã•ã‚ŒãŸå€¤ã«åŸºã¥ã„ã¦ã€å¤‰æ•°ã®å‹ã‚’è‡ªå‹•çš„ã«æ¨æ¸¬ã—ã¾ã™ã€‚ã“ã‚Œã‚’**å‹æ¨è«–**ã¨å‘¼ã³ã¾ã™ã€‚

```
let age = 20;   // Will be assigned type Nat / å‹ Nat ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚
```
> For the duration of the Bootcamp it is recommended to keep all type declarations to make things clearer, especially if you are new to typed languages.

> ç‰¹ã«å‹ä»˜ãè¨€èªã«æ…£ã‚Œã¦ã„ãªã„äººã¯ã€ç‰©äº‹ã‚’æ˜ç¢ºã«ã™ã‚‹ãŸã‚ã«ã€Bootcamp ã®æœŸé–“ä¸­ã€ã™ã¹ã¦ã®å‹å®£è¨€ã‚’ä¿æŒã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚

## ğŸ’¬ Comments. / ã‚³ãƒ¡ãƒ³ãƒˆ
A one-line comment is written by starting the line with `//`.  
ä¸€è¡Œã‚³ãƒ¡ãƒ³ãƒˆã¯ã€è¡Œé ­ã‚’ `//` ã§å§‹ã‚ã‚‹ã“ã¨ã§è¨˜è¿°ã—ã¾ã™ã€‚
```motoko
// Hello! It is recommended to use comments to make your code more readable.
```

A comment can span into multiple lines, in that case you'll need to add `//` on each line.  
ã‚³ãƒ¡ãƒ³ãƒˆã¯è¤‡æ•°è¡Œã«ã¾ãŸãŒã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ãŒã€ãã®å ´åˆã¯å„è¡Œã« `//` ã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
```motoko
//  Sometimes you'll have a lot to say
//  In those cases 
//  You can use more than one line
```

## âš™ï¸ Functions / é–¢æ•°
This section focuses solely on functions that are defined within the body of an actor using the `actor {}` syntax. Any function that is outside the `actor {}` syntax will be covered in future chapters.

ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§ã¯ã€`actor {}` æ§‹æ–‡ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¯ã‚¿ãƒ¼ã®æœ¬ä½“å†…ã§å®šç¾©ã•ã‚Œã‚‹é–¢æ•°ã«ã®ã¿ç„¦ç‚¹ã‚’å½“ã¦ã¾ã™ã€‚`actor {}` æ§‹æ–‡ã®å¤–å´ã«ã‚ã‚‹é–¢æ•°ã¯ã€ä»Šå¾Œã®ç« ã§ã‚«ãƒãƒ¼ã—ã¾ã™ã€‚

### A simple example / ç°¡å˜ãªä¾‹
To introduce functions - let's look at an example: here is an actor that is responsible to keep track of a  counter. 

é–¢æ•°ã‚’ç´¹ä»‹ã™ã‚‹ãŸã‚ã«ã€ä¾‹ã‚’è¦‹ã¦ã¿ã¾ã—ã‚‡ã†ã€‚ã‚ã‚‹ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚’è¨˜éŒ²ã™ã‚‹å½¹å‰²ã‚’æŒã¤ã‚¢ã‚¯ã‚¿ãƒ¼ãŒã„ã¾ã™ã€‚

```motoko
actor Counter {
    var count : Nat = 0;

    public func setCount(n : Nat) : async Nat {
        count := n;
        return count;
    };

};
```

The keyword `func` is used to declare functions, followed by the name given to the function, in that case `increaseCount`. As for variables, the syntax convention is to use `lowerCamelCase` for function names.  <br/>

é–¢æ•°ã‚’å®£è¨€ã™ã‚‹ã«ã¯ã€ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ `func` ã‚’ä½¿ç”¨ã—ã€ãã®å¾Œã«é–¢æ•°åï¼ˆã“ã®å ´åˆã¯ `increaseCount` ï¼‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚å¤‰æ•°ã¨åŒæ§˜ã«ã€é–¢æ•°åã«ã¯ `lowerCamelCase` ã‚’ä½¿ç”¨ã™ã‚‹ã®ãŒæ§‹æ–‡ä¸Šã®è¦å‰‡ã§ã™ã€‚<br/>

### Function type / é–¢æ•°å‹
When defining a function in Motoko, the typed arguments and return type are used to determine the type of the function as a whole. For example, the function setCount has the following type:  
Motoko ã§é–¢æ•°ã‚’å®šç¾©ã™ã‚‹å ´åˆã€å‹ä»˜ãå¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹ã‹ã‚‰ã€é–¢æ•°å…¨ä½“ã®å‹ãŒæ±ºå®šã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€é–¢æ•° setCount ã¯æ¬¡ã®ã‚ˆã†ãªå‹ã‚’æŒã£ã¦ã„ã¾ã™ï¼š
```motoko
setCount : (n : Nat) -> async Nat;
```
To declare a function in Motoko, you must specify the types of the arguments and return values. Function arguments are enclosed in parentheses `()`, and in this case, the function takes an argument `n` of type `Nat`. After the function arguments, the return type is specified : `async Nat`.  
Motokoã§é–¢æ•°ã‚’å®£è¨€ã™ã‚‹ã«ã¯ã€å¼•æ•°ã¨æˆ»ã‚Šå€¤ã®å‹ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚é–¢æ•°ã®å¼•æ•°ã¯æ‹¬å¼§ `()` ã§å›²ã¾ã‚Œã€ã“ã®å ´åˆã€é–¢æ•°ã¯ `Nat` å‹ã®å¼•æ•° `n` ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚é–¢æ•°ã®å¼•æ•°ã®å¾Œã«ã¯ã€æˆ»ã‚Šå€¤ã®å‹ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã™ : `async Nat`

> You might be wondering why the return type for the `setCount` function is `async Nat` instead of simply `Nat`? <br/> The term `async` stands for asynchronous, which means that in the **Actor model** we discussed earlier, canisters or actors communicate with each other asynchronously. When one canister sends a request to another (or when a user calls a function), there will be a brief waiting period before the caller receives a response. <br/> 
Asynchronous programming allows you to run your code in a non-blocking manner. The `async Nat` return type for the `setCount` function indicates that the caller must wait for a few moments before receiving the return value. Eventually, the response will be a value of type `Nat`, but with a delay due to the asynchronous nature of the communication between canisters. **All public functions declared in the body of an actor must be of return type `async`**. 

> `setCount` é–¢æ•°ã®æˆ»ã‚Šå€¤ãŒå˜ãªã‚‹ `Nat` ã§ã¯ãªã `async Nat` ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã‚’ä¸æ€è­°ã«æ€ã£ã¦ã„ã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚`async` ã¨ã„ã†ç”¨èªã¯ asynchronous ã®ç•¥ã§ã€å…ˆã»ã©èª¬æ˜ã—ãŸ **Actorãƒ¢ãƒ‡ãƒ«** ã§ã¯ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¾ãŸã¯ã‚¢ã‚¯ã‚¿ãƒ¼ã¯äº’ã„ã«éåŒæœŸã§é€šä¿¡ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ã‚ã‚‹ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒåˆ¥ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹ã¨ãï¼ˆã¾ãŸã¯ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒé–¢æ•°ã‚’å‘¼ã³å‡ºã™ã¨ãï¼‰ã€å‘¼ã³å‡ºã—å…ƒãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å—ã‘å–ã‚‹ã¾ã§ã«çŸ­ã„å¾…ã¡æ™‚é–“ãŒç™ºç”Ÿã—ã¾ã™ã€‚ <br/>éåŒæœŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã§ã¯ã€ã‚³ãƒ¼ãƒ‰ã‚’ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ã§å®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚`setCount`é–¢æ•°ã® `async Nat` æˆ»ã‚Šå€¤ã®å‹ã¯ã€å‘¼ã³å‡ºã—å´ãŒæˆ»ã‚Šå€¤ã‚’å—ã‘å–ã‚‹ã¾ã§ã—ã°ã‚‰ãå¾…ãŸãªã‘ã‚Œã°ãªã‚‰ãªã„ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚æœ€çµ‚çš„ã«ã€å¿œç­”ã¯ `Nat` å‹ã®å€¤ã¨ãªã‚Šã¾ã™ãŒã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼é–“ã®é€šä¿¡ãŒéåŒæœŸã§ã‚ã‚‹ãŸã‚ã€é…å»¶ãŒç™ºç”Ÿã—ã¾ã™ã€‚ **ã‚¢ã‚¯ã‚¿ãƒ¼æœ¬ä½“ã§å®£è¨€ã•ã‚Œã‚‹ã™ã¹ã¦ã®ãƒ‘ãƒ–ãƒªãƒƒã‚¯é–¢æ•°ã¯ã€æˆ»ã‚Šå€¤ã®å‹ãŒ `async`** ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

### Body and return / Body ã¨ return
- The curly brackets `{}` are used for the function body. The body of the function is a set of instructions executed when the function is being called.
In our example, for `setCount` we have 2 instructions:
1. Assign the value of `count` to the value of `n`. 
2. Return the current value of `count`.

- ä¸­æ‹¬å¼§ `{}` ã¯é–¢æ•°æœ¬ä½“ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚é–¢æ•°æœ¬ä½“ã¯ã€é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚ŒãŸã¨ãã«å®Ÿè¡Œã•ã‚Œã‚‹å‘½ä»¤ã®é›†åˆã§ã™ã€‚
ã“ã®ä¾‹ã§ã¯ã€`setCount`ã«å¯¾ã—ã¦ã€2ã¤ã®å‘½ä»¤ã‚’ç”¨æ„ã—ã¦ã„ã¾ã™ï¼š
1. `count`ã®å€¤ã‚’`n`ã®å€¤ã¸ä»£å…¥ã™ã‚‹ã€‚
2. ç¾åœ¨ã® `count` ã®å€¤ã‚’è¿”ã™ã€‚

Motoko allows to omit the `return` at the end of the body of the function, because a block always evaluates to its last expression. Which means, we could rewrite the code in the following way and it would still be valid:  
Motoko ã§ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ã¯å¸¸ã«æœ€å¾Œã®å¼ã§è©•ä¾¡ã•ã‚Œã‚‹ãŸã‚ã€é–¢æ•°æœ¬ä½“ã®æœ€å¾Œã«ã‚ã‚‹ `return` ã‚’çœç•¥ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã¤ã¾ã‚Šã€æ¬¡ã®ã‚ˆã†ã«ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãæ›ãˆã¦ã‚‚æœ‰åŠ¹ã¨ã„ã†ã“ã¨ã§ã™ï¼š

```motoko
public func setCount(n : Nat) : async Nat {
    count := n;
    count;
};
```
### Public vs Private
So far we've only seen `public` functions. However, in Motoko you can also define `private` functions.  
ã“ã“ã¾ã§ã¯ã€`public` é–¢æ•°ã ã‘ã‚’è¦‹ã¦ãã¾ã—ãŸã€‚ã—ã‹ã—ã€Motokoã§ã¯ `private` é–¢æ•°ã‚‚å®šç¾©ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```motoko
private func add(n : Nat, m : Nat) : Nat {
    return (n + m)
};
```
The function is now marked `private`, this means that it can only be used by the actor himself and cannot be called directly by users or external canisters.  
ã“ã®é–¢æ•°ã¯ç¾åœ¨`private`ã¨ãƒãƒ¼ã‚¯ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã¯ã‚¢ã‚¯ã‚¿ãƒ¼è‡ªèº«ã®ã¿ãŒä½¿ç”¨ã§ãã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¾ãŸã¯å¤–éƒ¨ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‹ã‚‰ç›´æ¥å‘¼ã³å‡ºã™ã“ã¨ãŒã§ããªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚

Usually `private` functions are used as helpers in other functions, that are generally defined as `public`. For instance we could write the following.  
é€šå¸¸ã€`private`é–¢æ•°ã¯ã€ä¸€èˆ¬çš„ã«`public`ã¨ã—ã¦å®šç¾©ã•ã‚Œã¦ã„ã‚‹ä»–ã®é–¢æ•°ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ä¾‹ãˆã°ã€æ¬¡ã®ã‚ˆã†ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚

```motoko
actor {
    var count : Nat = 0;

    private func add(n : Nat, m : Nat) : Nat {
        return (n + m)
    };

    public func addCount(n : Nat) : async Nat {
        let newCount = add(count,n);
        count := newCount;
        return count;
    };
}
```

> We can remove the `private` keyword , a function declaration defaults to a private function in Motoko unless declared otherwise (i.e unless declared `public`).

> `private` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å‰Šé™¤ã™ã‚Œã°ã€Motoko ã®é–¢æ•°å®£è¨€ã¯ã€ãã†ã§ãªã„å ´åˆï¼ˆã¤ã¾ã‚Šã€`public`ã¨å®£è¨€ã•ã‚Œã¦ã„ãªã„å ´åˆï¼‰ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ private é–¢æ•°ã¨ãªã‚Šã¾ã™ã€‚


## ğŸ•¹ï¸ Control flow. / åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼
Control flow refers to the order in which a program is executed and the order that it follows. It decides which statements, instructions or function calls are executed and in what order, based on conditions or decisions made during the run time. <br/>
åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã¨ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å®Ÿè¡Œé †åºã¨ãã‚Œã«å¾“ã†é †åºã®ã“ã¨ã§ã™ã€‚å®Ÿè¡Œæ™‚ã®æ¡ä»¶ã‚„åˆ¤æ–­ã«åŸºã¥ãã€ã©ã®æ–‡ã‚„å‘½ä»¤ã€é–¢æ•°å‘¼ã³å‡ºã—ãŒã©ã®ã‚ˆã†ãªé †åºã§å®Ÿè¡Œã•ã‚Œã‚‹ã‹ã‚’æ±ºå®šã™ã‚‹ã‚‚ã®ã§ã™ã€‚<br/>

We discuss three common control flow constructs in Motoko: `if else` expressions, `loops` expressions and `switch` expressions.

ã“ã“ã§ã¯ã€Motokoã§ã‚ˆãä½¿ã‚ã‚Œã‚‹3ã¤ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ§‹æˆè¦ç´ ã€`if else`å¼ã€`loop`å¼ã€`switch`å¼ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚

### If/else
The `if` statement allows the program to make a decision and execute a certain block of code only if a specific condition is met. The optional `else` statement provides an alternative if the condition is not met.  
`if` æ–‡ã¯ã€ç‰¹å®šã®æ¡ä»¶ãŒæº€ãŸã•ã‚ŒãŸå ´åˆã«ã®ã¿ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒåˆ¤æ–­ã‚’ä¸‹ã—ã€ç‰¹å®šã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã® `else` æ–‡ã¯ã€æ¡ä»¶ãŒæº€ãŸã•ã‚Œãªã„å ´åˆã®ä»£æ›¿æ¡ˆã‚’æä¾›ã—ã¾ã™ã€‚
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true
        } else {
            return false
        };
    };
```
In this case, the condition `n % 2` will be tested at runtime and depending on the value of `n` will returns `true` or `false`.  
ã“ã®å ´åˆã€å®Ÿè¡Œæ™‚ã« `n % 2` ã¨ã„ã†æ¡ä»¶ãŒãƒ†ã‚¹ãƒˆã•ã‚Œã€`n` ã®å€¤ã«å¿œã˜ã¦ `true` ã¾ãŸã¯ `false` ãŒè¿”ã•ã‚Œã¾ã™ã€‚ 
In many cases the `else` block can be removed without modyfing the behavior of the code block.  
å¤šãã®å ´åˆã€`else`ãƒ–ãƒ­ãƒƒã‚¯ã¯ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®å‹•ä½œã‚’å¤‰æ›´ã™ã‚‹ã“ã¨ãªãå‰Šé™¤ã§ãã¾ã™ã€‚
```motoko
    func isEven(n : Nat) : Bool {
        if(n % 2 == 0){
            return true;
        };
        return false;
    };
```
In other cases, you can add `else if` blocks to check additional conditions.  
ãã®ä»–ã®å ´åˆã¯ã€`else if` ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã—ã¦ã€è¿½åŠ ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ã§ãã¾ã™ã€‚
```motoko
    func checkNumber(i : Int) : Text {
        if(n < 0) {
            return ("The number is negative.");
        } else if (n == 0) {
            return("The number is zero.");
        } else if (n < 10) {
            return("The number is one digits.");
        } else if (n < 100) {
            return("The number is two digits.");
        } else {
            return ("The number is three or more digits.");
        }
    };
```
Note that `else if` statements are used after the initial `if` statement to check additional conditions, and only the code block associated with the first condition that evaluates to true will be executed.  
æœ€åˆã® `if` ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã®å¾Œã« `else if` ã‚¹ãƒ†ãƒ¼ãƒˆãƒ¡ãƒ³ãƒˆã‚’ä½¿ç”¨ã—ã¦è¿½åŠ ã®æ¡ä»¶ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€true ã¨è©•ä¾¡ã•ã‚ŒãŸæœ€åˆã®æ¡ä»¶ã«é–¢é€£ã™ã‚‹ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã®ã¿ãŒå®Ÿè¡Œã•ã‚Œã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
### Loops / ãƒ«ãƒ¼ãƒ—
Loops enable the repeated execution of a code block until a specific condition is fulfilled. There are various types of loops, such as `for` loops and `while` loops:  
ãƒ«ãƒ¼ãƒ—ã¯ã€ç‰¹å®šã®æ¡ä»¶ãŒæº€ãŸã•ã‚Œã‚‹ã¾ã§ã€ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç¹°ã‚Šè¿”ã—å®Ÿè¡Œã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚ãƒ«ãƒ¼ãƒ—ã«ã¯ã€`for`ãƒ«ãƒ¼ãƒ—ã‚„`while`ãƒ«ãƒ¼ãƒ—ãªã©ã€ã•ã¾ã–ã¾ãªç¨®é¡ãŒã‚ã‚‹ï¼š
- `for` loops in Motoko use an iterator of the `Iter` type. We will delve into the `Iter` type in a later chapter, but to summarize, `Iter` objects facilitate looping through collections of data.
- Motoko ã® `for` ãƒ«ãƒ¼ãƒ—ã¯ `Iter` å‹ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`Iter` å‹ã«ã¤ã„ã¦ã¯å¾Œã®ç« ã§è©³ã—ãèª¬æ˜ã—ã¾ã™ãŒã€è¦ç´„ã™ã‚‹ã¨ã€`Iter` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã“ã¨ã‚’å®¹æ˜“ã«ã—ã¾ã™ã€‚

```motoko
var count : Nat = 0;
for (x in Iter.range(0, 10)) {
    count += 1;
};
```
In this example, `Iter.range(0, 10)` iterates through all natural numbers between 0 and 10, inclusive of both boundaries.  
ã“ã®ä¾‹ã§ã¯ã€`Iter.range(0, 10)` ã¯ã€0ã‹ã‚‰10ã¾ã§ã®ã™ã¹ã¦ã®è‡ªç„¶æ•°ï¼ˆä¸¡ç«¯ã‚’å«ã‚€ï¼‰ã‚’åå¾©å‡¦ç†ã—ã¾ã™ã€‚

Alternatively, you can use `while` loops, which executes as long as the specified conditions remains true.  
ã¾ãŸã€`while`ãƒ«ãƒ¼ãƒ—ã‚’ä½¿ãˆã°ã€æŒ‡å®šã—ãŸæ¡ä»¶ãŒçœŸã§ã‚ã‚‹é™ã‚Šå®Ÿè¡Œã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

```motoko
var count : Nat = 0;
while (count < 10) {
    count += 1;
};
```
Here, the loop will continue to execute until the `count` variable is no longer less than 10.  
ã“ã“ã§ã¯ã€å¤‰æ•° `count` ãŒ10ã‚ˆã‚Šå°ã•ããªããªã‚‹ã¾ã§ã€ãƒ«ãƒ¼ãƒ—ã‚’å®Ÿè¡Œã—ç¶šã‘ã¾ã™ã€‚

### Switch/case
The `switch` expression in Motoko is a control flow construct that matches patterns based on its input. It begins with the `switch` keyword, followed by the input expression enclosed in parentheses `()`, and a code block enclosed in curly braces `{}`.  
Motokoã® `switch` å¼ã¯ã€å…¥åŠ›ã«åŸºã¥ã„ã¦ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ãƒãƒƒãƒãƒ³ã‚°ã™ã‚‹åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼æ§‹æˆä½“ã§ã™ã€‚ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ `switch` ã§å§‹ã¾ã‚Šã€å…¥åŠ›å¼ã‚’æ‹¬å¼§ `()` ã§å›²ã¿ã€ä¸­æ‹¬å¼§ `{}` ã§å›²ã‚“ã ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒç¶šãã¾ã™ã€‚
```motoko
let x = 3;
switch(x) {
    //
};
```
Within the code block, the `case` keyword is used to define patterns and expressions enclosed in curly braces `{}`. The input is compared to the patterns specified in each case, and if a match is found, the expression within the corresponding `case` block is executed.  
ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯å†…ã§ã¯ã€ä¸­æ‹¬å¼§ `{}` ã§å›²ã¾ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã‚„å¼ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã« `case` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚å…¥åŠ›ã¯ãã‚Œãã‚Œã®ã‚±ãƒ¼ã‚¹ã§æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã¨æ¯”è¼ƒã•ã‚Œã€ä¸€è‡´ã™ã‚‹ã‚‚ã®ãŒã‚ã‚Œã°ã€å¯¾å¿œã™ã‚‹ `case` ãƒ–ãƒ­ãƒƒã‚¯å†…ã®å¼ãŒå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚
```motoko
let x = 3;
switch(x) {
    case(0) {
        // This corresponds to the case x == 0
        return ("x is equal to 0");
    };
    case (1) {
        // This corresponds to the case x == 1
        return ("x is equal to 1");
    };
    case (2) {
        // This corresponds to the case x == 2
        return ("x is equal to 2");
    };
    case (_) {
        // This corresponds to all other cases
        return ("x is above 2");
    };
};
```
In Motoko, it is mandatory to include a `case(_)` statement for every possible input value in a `switch` expression. This is why the case(`_`) pattern is sometimes used as a catch-all case to handle any input value that did not match any of the other cases. The underscore symbol (`_`) is a wildcard that matches any value, so the `case(_)` pattern will match any input value.  
Motoko ã§ã¯ã€`switch`å¼ã«å«ã¾ã‚Œã‚‹ã™ã¹ã¦ã®å¯èƒ½ãªå…¥åŠ›å€¤ã«å¯¾ã—ã¦ `case(_)` æ–‡ã‚’å«ã‚ã‚‹ã“ã¨ãŒç¾©å‹™ä»˜ã‘ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€case(`_`)ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€ä»–ã®ã©ã®ã‚±ãƒ¼ã‚¹ã«ã‚‚ãƒãƒƒãƒã—ãªã‹ã£ãŸå…¥åŠ›å€¤ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã®ã‚­ãƒ£ãƒƒãƒã‚ªãƒ¼ãƒ«ã‚±ãƒ¼ã‚¹ã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢è¨˜å· (`_`) ã¯ã©ã‚“ãªå€¤ã«ã‚‚ãƒãƒƒãƒã™ã‚‹ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ãªã®ã§ã€`case(_)` ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã©ã‚“ãªå…¥åŠ›å€¤ã«ã‚‚ãƒãƒƒãƒã—ã¾ã™ã€‚

The `switch/case` expression is best used with variants.  
`switch/case`è¡¨ç¾ã¯ãƒãƒªã‚¢ãƒ³ãƒˆã¨ä¸€ç·’ã«ä½¿ã†ã®ãŒãƒ™ã‚¹ãƒˆã§ã™ã€‚

```motoko
type Day = {
    #Monday;
    #Tuesday;
    #Wednesday;
    #Thursday;
    #Friday;
    #Saturday;
    #Sunday;
};
let day = #Monday;

switch(day) {
    case(#Monday){
        return ("Today is Monday");
    };
    case(#Tuesday){
        return ("Today is Tuesday");
    };
    case(#Wednesday){
        return ("Today is Wednesday");
    };
    case(#Thursday){
        return ("Today is Thursday");
    };
    case(#Friday){
        return ("Today is Friday");
    };
    case(#Saturday){
        return ("Today is Saturday");
    };
    case(#Sunday){
        return ("Enjoy your Sunday");
    };
};
```
In this example, we defined a variant type `Day`, declared a variable `day` with that type, and then used it as input in our `switch` expression. The switch expression is a powerful control flow construct that allows for pattern matching, providing a concise and readable way to handle multiple cases based on the input value.  
ã“ã®ä¾‹ã§ã¯ã€ãƒãƒªã‚¢ãƒ³ãƒˆã‚¿ã‚¤ãƒ— `Day` ã‚’å®šç¾©ã—ã€ãã®ã‚¿ã‚¤ãƒ—ã‚’æŒã¤å¤‰æ•° `day` ã‚’å®£è¨€ã—ã€ãã‚Œã‚’ `switch` å¼ã®å…¥åŠ›ã¨ã—ã¦ä½¿ç”¨ã—ã¾ã™ã€‚ã‚¹ã‚¤ãƒƒãƒå¼ã¯ã€ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒã‚’å¯èƒ½ã«ã™ã‚‹å¼·åŠ›ãªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ•ãƒ­ãƒ¼æ§‹é€ ã§ã€å…¥åŠ›å€¤ã«åŸºã¥ã„ã¦è¤‡æ•°ã®ã‚±ãƒ¼ã‚¹ã‚’å‡¦ç†ã™ã‚‹ç°¡æ½”ã§èª­ã¿ã‚„ã™ã„æ–¹æ³•ã‚’æä¾›ã—ã¾ã™ã€‚