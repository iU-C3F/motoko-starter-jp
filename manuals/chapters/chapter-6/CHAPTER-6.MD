# Chapter 6: Storing data in data structures. / ç¬¬6ç«  ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã§ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜
## ğŸ—ƒï¸ Array / é…åˆ—
In Motoko, an array of type `Array` is a group of **similar** elements (i.e same type) that are stored together. To create an array, one must specify the types of elements that the array will contain. 
For instance, here is how to create an array that will hold `Nat`.  
Motoko ã§ã¯ã€`Array`å‹ã®é…åˆ—ã¯ã€ä¸€ç·’ã«ä¿å­˜ã•ã‚Œã‚‹ **é¡ä¼¼** è¦ç´ ï¼ˆã™ãªã‚ã¡åŒã˜å‹ï¼‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã§ã‚ã‚‹ã€‚é…åˆ—ã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ãã®é…åˆ—ã«å«ã¾ã‚Œã‚‹è¦ç´ ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
ä¾‹ãˆã°ã€`Nat`ã‚’æ ¼ç´ã™ã‚‹é…åˆ—ã‚’ä½œæˆã™ã‚‹æ–¹æ³•ã‚’ä»¥ä¸‹ã«ç¤ºã—ã¾ã™ã€‚

```motoko
let ages : [Nat] = [16, 32, 25, 8, 89];
```
An array that will hold values of type `Text`.
```motoko
let words : [Text] = ["Motoko", "is", "the", "best", "language"];
```
Contrary to other programming languages which might be more flexible in that regard, in Motoko we can't mix elements of different types in the same array.  
ä»–ã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã¯ã‚‚ã£ã¨æŸ”è»Ÿã«å¯¾å¿œã§ãã‚‹ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ãŒã€Motoko ã§ã¯åŒã˜é…åˆ—ã®ä¸­ã«ç•°ãªã‚‹å‹ã®è¦ç´ ã‚’æ··åœ¨ã•ã›ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚<br/>
The following code will throw an error: `literal of type Text does not have expected type Nat`.  
ä¸‹è¨˜ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ï¼š`literal of type Text does not have expected type Nat`ã€‚
```motoko
let array : [Nat] = [14, 16, 32, 25, "Motoko"];
```
<p align="center"> <img src="assets/array.png" width="600px" style="border: 2px solid black;"></p>
To access a specific element within an array, we use its index. Keep in mind that arrays in Motoko are zero-indexed, which means that the first element is at position 0, the second element is at position 1, and so on. For example, to access the first element of an array named `myArray`, we would use `myArray[0]`, and to access the second element, we would use `myArray[1]`.

é…åˆ—ã®ä¸­ã®ç‰¹å®šã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€ãã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚Motoko ã®é…åˆ—ã¯ã‚¼ãƒ­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã§ã‚ã‚‹ã“ã¨ã«ç•™æ„ã—ã¦ãã ã•ã„ã€‚ã¤ã¾ã‚Šã€æœ€åˆã®è¦ç´ ã¯ 0 ç•ªã€2 ç•ªç›®ã®è¦ç´ ã¯ 1 ç•ªã€ã¨ã„ã£ãŸå…·åˆã«ãªã‚Šã¾ã™ã€‚ä¾‹ãˆã°ã€`myArray` ã¨ã„ã†åå‰ã®é…åˆ—ã®æœ€åˆã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€`myArray[0]` ã‚’ä½¿ã„ã€2ç•ªç›®ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€`myArray[1]` ã‚’ä½¿ã†ã“ã¨ã«ãªã‚‹ã§ã—ã‚‡ã†ã€‚
```motoko
let myArray : [Nat] = [23, 16, 32, 25];
let a = myArray[0]  // 23
let b = myArray[3]  // 25
```
We can access the size of an array using the `.size()` method.  
é…åˆ—ã®ã‚µã‚¤ã‚ºã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€`.size()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```motoko
let names : [Text] = ["Emma Smith", "Olivia Johnson", "Ava Brown", "Isabella Davis"];
let size = names.size();    // 4
```

To loop over an array we can use the `.vals()` iterator. Here is an example that would gave us the sum of an array.  
é…åˆ—ã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ãŸã‚ã«ã¯ã€`.vals()` ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ä»¥ä¸‹ã¯ã€é…åˆ—ã®å’Œã‚’æ±‚ã‚ã‚‹ä¾‹ã§ã™ã€‚
```motoko
actor {
    let array : [Nat] = [1, 2, 3, 4, 5];
    var sum : Nat = 0;

    public func somme_array() : async Nat {
        for (value in array.vals()){
          sum := sum + value;
        };
       return sum; 
    };
};
```

In Motoko, arrays have a fixed size that is determined when the array is created. This means that the size cannot be increased later on. To add a new element to an array, a new array must be created and all of the existing elements must be transferred to the new array manually. This makes `Array` not really adapted for datastructures that needs be constantly updated.  
Motoko ã§ã¯ã€é…åˆ—ã®ã‚µã‚¤ã‚ºã¯ä½œæˆæ™‚ã«å›ºå®šã§æ±ºå®šã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€å¾Œã‹ã‚‰ã‚µã‚¤ã‚ºã‚’å¤§ããã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚é…åˆ—ã«æ–°ã—ã„è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€æ–°ã—ã„é…åˆ—ã‚’ä½œæˆã—ã€æ—¢å­˜ã®è¦ç´ ã‚’ã™ã¹ã¦æ‰‹å‹•ã§æ–°ã—ã„é…åˆ—ã«ç§»ã•ãªã‘ã‚Œã°ãªã‚‰ãªã„ã€‚ã“ã®ãŸã‚ã€`Array`ã¯å¸¸ã«æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã«ã¯ã‚ã¾ã‚Šé©ã—ã¦ã„ã¾ã›ã‚“ã€‚

Concatenating two arrays to an `Array` can be done using `Array.append()` - a function from the [Array](https://internetcomputer.org/docs/current/motoko/main/base/Array) module.  
[Array](https://internetcomputer.org/docs/current/motoko/main/base/Array) ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®é–¢æ•°ã§ã‚ã‚‹ `Array.append()` ã‚’ä½¿ã£ã¦ã€2ã¤ã®é…åˆ—ã‚’1ã¤ã® `Array` ã«é€£çµã§ãã¾ã™ã€‚
```motoko
let array1 = [1, 2, 3];
let array2 = [4, 5, 6];
Array.append<Nat>(array1, array2) // [1, 2, 3, 4, 5, 6];
```
However, this function is **depreceated**. It is recommended to avoid it in production code. That's because as we've said before it is impossible to simply add elements to an array. Under the hood, `Array.append()` will create a new array and copy the values of the two existing arrays which is not efficient.  
ãŸã ã—ã€ã“ã®æ©Ÿèƒ½ã¯ **éæ¨å¥¨** ã§ã™ã€‚æœ¬ç•ªã®ã‚³ãƒ¼ãƒ‰ã§ã¯é¿ã‘ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™ã€‚ãã‚Œã¯ã€å…ˆã«è¿°ã¹ãŸã‚ˆã†ã«ã€é…åˆ—ã«è¦ç´ ã‚’å˜ç´”ã«è¿½åŠ ã™ã‚‹ã“ã¨ã¯ä¸å¯èƒ½ã ã‹ã‚‰ã§ã™ã€‚Array.append()`ã¯ã€æ–°ã—ã„é…åˆ—ã‚’ä½œæˆã—ã€æ—¢å­˜ã®2ã¤ã®é…åˆ—ã®å€¤ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã™ãŒã€ã“ã‚Œã¯åŠ¹ç‡çš„ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

## ğŸ¥ Buffer / ãƒãƒƒãƒ•ã‚¡ãƒ¼
A more adapted structure to dynamically add new elements is the type `Buffer`. 
A `Buffer` can be instantiated using the [Buffer](https://internetcomputer.org/docs/current/motoko/main/base/Buffer) library. 
One needs to provide the types of elements stored inside and the initial capacity. 
The initial capacity represents the length of the underyling array that backs this list. In most cases, you will not have to worry about the `capacity` since the Buffer will automatically grow or resize the underlying array that holds the elements.

æ–°ã—ã„è¦ç´ ã‚’å‹•çš„ã«è¿½åŠ ã™ã‚‹ãŸã‚ã«ã€ã‚ˆã‚Šé©åˆã—ãŸæ§‹é€ ã¯ `Buffer` å‹ã§ã™ã€‚
`Buffer`ã¯ã€[Buffer](https://internetcomputer.org/docs/current/motoko/main/base/Buffer) ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨ã—ã¦ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã§ãã¾ã™ã€‚
å†…éƒ¨ã«æ ¼ç´ã•ã‚Œã‚‹è¦ç´ ã®ç¨®é¡ã¨åˆæœŸå®¹é‡ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
åˆæœŸå®¹é‡ã¯ã€ã“ã®ãƒªã‚¹ãƒˆã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã™ã‚‹åŸºç¤é…åˆ—ã®é•·ã•ã‚’è¡¨ã—ã¾ã™ã€‚ã»ã¨ã‚“ã©ã®å ´åˆã€Buffer ã¯è‡ªå‹•çš„ã«è¦ç´ ã‚’ä¿æŒã™ã‚‹é…åˆ—ã®ã‚µã‚¤ã‚ºã‚’å¤§ããã—ãŸã‚Šå°ã•ãã—ãŸã‚Šã™ã‚‹ã®ã§ã€`å®¹é‡`ã‚’æ°—ã«ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
```motoko
import Buffer "mo:base/Buffer";
actor {
    let b = Buffer.Buffer<Nat>(2);
}
```
In this case, the types of elements in the buffer is `Nat` and the initial capacity of the buffer is `2`.  
ã“ã®å ´åˆï¼Œãƒãƒƒãƒ•ã‚¡ã®è¦ç´ ã®ç¨®é¡ã¯ `Nat` ã§ï¼Œãƒãƒƒãƒ•ã‚¡ã®åˆæœŸå®¹é‡ã¯ `2` ã¨ãªã‚Šã¾ã™ï¼

To add an element use the `.add()` method.  
è¦ç´ ã‚’è¿½åŠ ã™ã‚‹ã«ã¯ã€`.add()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
```motoko
b.add(0);   // add 0 to buffer / ãƒãƒƒãƒ•ã‚¡ã« 0 ã‚’è¿½åŠ ã™ã‚‹
b.add(10);   // add 10 to buffer / ãƒãƒƒãƒ•ã‚¡ã« 10 ã‚’è¿½åŠ ã™ã‚‹
b.add(100)    // causes underlying arrray to increase in capacity since the capacity was set to 2 / å®¹é‡ãŒ 2 ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€åŸºç¤ã¨ãªã‚‹é…åˆ—ã®å®¹é‡ãŒå¢—ãˆã‚‹
```
To get the number of elements in the buffer use the `.size()` method. The `size` is different than the capacity we've mentionned earlier since it represents the number of elements that are actually stored in the buffer.  
ãƒãƒƒãƒ•ã‚¡å†…ã®è¦ç´ æ•°ã‚’å–å¾—ã™ã‚‹ã«ã¯ã€`.size()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚`size`ã¯ã€å…ˆã«è¿°ã¹ãŸå®¹é‡ã¨ã¯ç•°ãªã‚Šã€å®Ÿéš›ã«ãƒãƒƒãƒ•ã‚¡ã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹è¦ç´ ã®æ•°ã‚’è¡¨ã—ã¾ã™ã€‚
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
b.add(100);  
b.size();   // 3
```
To access an elements in the buffer, use the `.get()` method and provides the index. Traps if `index` >= `size`. Indexing is zero-based like with `Array`.  
ãƒãƒƒãƒ•ã‚¡å†…ã®è¦ç´ ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã«ã¯ã€`.get()`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€‚index` >= `size` ã®å ´åˆã¯ãƒˆãƒ©ãƒƒãƒ—ã™ã‚‹ã€‚ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ `Array` ã¨åŒæ§˜ã«ã‚¼ãƒ­ãƒ™ãƒ¼ã‚¹ã§ã‚ã‚‹ã€‚
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
b.add(100);  
b.get(2);   // 100
```

A buffer can easily be converted to an array using the `toArray()` function from the [Buffer library](https://internetcomputer.org/docs/current/motoko/main/base/Buffer#function-toarray-1).  
Buffer ã¯ [Buffer library](https://internetcomputer.org/docs/current/motoko/main/base/Buffer#function-toarray-1) ã® `toArray()` é–¢æ•°ã‚’ç”¨ã„ã¦ç°¡å˜ã«é…åˆ—ã«å¤‰æ›ã§ãã¾ã™ã€‚
```motoko
let b = Buffer.Buffer<Nat>(2);
b.add(0);   
b.add(10);   
Buffer.toArray<Nat>(b); // [0, 10];
```
## ğŸ”— List
Purely-functional, singly-linked lists. A list of type List<T> is either null or an optional pair of a value of type T and a tail, itself of type List<T>.  
ç´”ç²‹ã«æ©Ÿèƒ½çš„ãªã€å˜ä¸€ãƒªãƒ³ã‚¯ã®ãƒªã‚¹ãƒˆã€‚List<T> å‹ã®ãƒªã‚¹ãƒˆã¯ï¼Œnull ã‹ï¼ŒT å‹ã®å€¤ã¨ List<T> å‹ã®æœ«å°¾ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒšã‚¢ã§ã‚ã‚‹ã‹ã®ã„ãšã‚Œã‹ã§ã™ã€‚

[List library](https://internetcomputer.org/docs/current/motoko/main/base/List/)
```motoko
type List<T> = ?(T, List<T>);
```
"The difference between a list and an array is that an array is stored as one contiguous block of bytes in memory and a list is 'scattered' around without the elements having to be adjacent to each other. The advantage is that we can use memory more efficiently by filling the memory more flexibly. The downside is that for operations on the whole list, we have to visit each element one by one which may be computationally expensive."
[source](https://web3.motoko-book.dev/base-library/data-structures/list.html)  
"ãƒªã‚¹ãƒˆ "ã¨ "é…åˆ— "ã®é•ã„ã¯ã€é…åˆ—ã¯ãƒ¡ãƒ¢ãƒªä¸Šã«1ã¤ã®é€£ç¶šã—ãŸãƒã‚¤ãƒˆã®ãƒ–ãƒ­ãƒƒã‚¯ã¨ã—ã¦æ ¼ç´ã•ã‚Œã€ãƒªã‚¹ãƒˆã¯è¦ç´ ãŒéš£æ¥ã—ã¦ã„ãªãã¦ã‚‚ã€Œæ•£åœ¨ã€ã—ã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚åˆ©ç‚¹ã¯ã€ã‚ˆã‚ŠæŸ”è»Ÿã«ãƒ¡ãƒ¢ãƒªã‚’åŸ‹ã‚ã‚‹ã“ã¨ã§ã€ã‚ˆã‚ŠåŠ¹ç‡çš„ã«ãƒ¡ãƒ¢ãƒªã‚’ä½¿ç”¨ã§ãã‚‹ã“ã¨ã§ã™ã€‚æ¬ ç‚¹ã¯ã€ãƒªã‚¹ãƒˆå…¨ä½“ã«å¯¾ã™ã‚‹æ“ä½œã®å ´åˆã€å„è¦ç´ ã‚’1ã¤ãšã¤è¨ªå•ã—ãªã‘ã‚Œã°ãªã‚‰ãšã€è¨ˆç®—ã‚³ã‚¹ãƒˆãŒé«˜ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã§ã™ã€‚"
[ã‚½ãƒ¼ã‚¹](https://web3.motoko-book.dev/base-library/data-structures/list.html)

Read about Lists and Recursive types [here](https://web3.motoko-book.dev/advanced-types/recursive-types.html).  
ãƒªã‚¹ãƒˆã¨å†å¸°å‹ã«ã¤ã„ã¦ã¯[ã“ã¡ã‚‰](https://web3.motoko-book.dev/advanced-types/recursive-types.html)ã‚’ã”è¦§ãã ã•ã„ã€‚

Here is an example of a function that retrieves the last element of a particular list.  
ã“ã“ã§ã¯ã€ã‚ã‚‹ãƒªã‚¹ãƒˆã®æœ€å¾Œã®è¦ç´ ã‚’å–å¾—ã™ã‚‹é–¢æ•°ã®ä¾‹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚
```motoko
func last<T>(l : List<T>) : ?T {
    switch l {
        case null { null };
        case (?(x, null)) { ?x };
        case (?(_, t)) { last<T>(t) };
    };
};
```

## ğŸ’¿ HashMap & TrieMap
In Motoko, [HashMap](https://internetcomputer.org/docs/current/references/motoko-ref/HashMap) and [TrieMap](https://internetcomputer.org/docs/current/references/motoko-ref/TrieMap) are both implemented as a Class and have the same interface. The only difference is that `TrieMap` is represented internaly by a `Trie` while `HashMap` is using `AssocList`. All examples that will follow use `HashMap` but it would be similar for `TrieMap`.  
Motoko ã§ã¯ã€[HashMap](https://internetcomputer.org/docs/current/references/motoko-ref/HashMap) ã¨ [TrieMap](https://internetcomputer.org/docs/current/references/motoko-ref/TrieMap) ã¯ã€ã©ã¡ã‚‰ã‚‚Classã¨ã—ã¦å®Ÿè£…ã•ã‚Œã¦ãŠã‚Šã€åŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã‚’æŒã£ã¦ã„ã¾ã™ã€‚å”¯ä¸€ã®é•ã„ã¯ã€`HashMap` ãŒ `AssocList` ã‚’ä½¿ã£ã¦ã„ã‚‹ã®ã«å¯¾ã—ã€`TrieMap` ã¯å†…éƒ¨çš„ã« `Trie` ã§è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã§ã™ã€‚ã“ã®å¾Œã®ä¾‹ã§ã¯ `HashMap` ã‚’ä½¿ç”¨ã™ã‚‹ãŒã€`TrieMap` ã§ã‚‚åŒæ§˜ã§ã™ã€‚

- K is the type of the key (`Nat`, `Text`, `Principal`...)
- Kã¯ ã‚­ãƒ¼ã®å‹ï¼ˆ`Nat`, `Text`, `Principal`...ï¼‰ã§ã™ã€‚
- V is type of the value that will be stored (User data, Token balance...)
- V ã¯ä¿å­˜ã•ã‚Œã‚‹å€¤ã®å‹ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã€ãƒˆãƒ¼ã‚¯ãƒ³æ®‹é«˜...ï¼‰ã§ã™ã€‚

```motoko
class HashMap<K, V>(initCapacity : Nat, keyEq : (K, K) -> Bool, keyHash : K -> Hash.Hash)
```

To instantiate a value from the class, we need to provide:  
ã‚¯ãƒ©ã‚¹ã‹ã‚‰å€¤ã‚’ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–ã™ã‚‹ãŸã‚ã«ã€ä»¥ä¸‹ã‚’æä¾›ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š
1. An initial capacity of type `Nat`. / `Nat`å‹ã®åˆæœŸå®¹é‡
    ```motoko
    initCapacity : Nat
    ```
2. A function that can be used for testing equality of the keys. / ã‚­ãƒ¼ã®ç­‰è³ªæ€§ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹é–¢æ•°
    ```motoko
    keyEq : (K, K) -> Bool
    ```
3. A function that can be used for hashing the keys. / ã‚­ãƒ¼ã®ãƒãƒƒã‚·ãƒ¥åŒ–ã«ä½¿ç”¨ã§ãã‚‹é–¢æ•°
    ```motoko
    keyHash : K -> Hash.Hash
    ```

Let's imagine that we want to store a `Student` associated with his `Principal`. Where `Student` is defined as  
ä¾‹ãˆã°ã€`Student` ã‚’ãã® `Principal` ã¨é–¢é€£ä»˜ã‘ã¦ä¿å­˜ã—ãŸã„ã¨ã—ã¾ã™ã€‚ã“ã“ã§ã€`Student`ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã‚‹ã€‚
```motoko
type Student = {
    name : Text;
    age : Nat;
    favoriteLanguage : Text;
    graduate : Bool;
};
```

In that case:  
ãã®å ´åˆã¯
- K is of type `Principal` and represents the key of the HashMap.
- Kã¯ `Principal` å‹ã§ã‚ã‚Šã€HashMap ã®ã‚­ãƒ¼ã‚’è¡¨ã™ã€‚
- V is of type `User` and represents the stored value. 
- V ã¯ `User` å‹ã§ã‚ã‚Šã€ä¿å­˜ã•ã‚ŒãŸå€¤ã‚’è¡¨ã™ã€‚ï¼ˆè¨³æ³¨ï¼šãŠãã‚‰ãèª¤å­—ã€‚`User` ã§ã¯ãªã `Student`ï¼‰

To initiate our `HashMap`  
`HashMap` ã‚’åˆæœŸåŒ–ã™ã‚‹ã«ã¯
```motoko
import HashMap "mo:base/HashMap";
import Principal "mo:base/Principal";
actor {
    type Student = {
        name : Text;
        age : Nat;
        favoriteLanguage : Text;
        graduate : Bool;
    };

    let map = HashMap.HashMap<Principal, Student>(1, Principal.equal, Principal.hash);
}
```
To add a new entry to the `map` we can use the `.put()` method.  
æ–°ã—ã„ã‚¨ãƒ³ãƒˆãƒªã‚’ `map` ã«è¿½åŠ ã™ã‚‹ã«ã¯ã€`.put()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
```motoko
map.put(principal, student);
```
This will insert the value `student` with key `principal` and overwrites any previous value. We can use this method to create a `register` function that students would need to call and provide all their relevant informations.  
ã“ã‚Œã«ã‚ˆã‚Šã€ã‚­ãƒ¼ `principal` ã‚’æŒã¤å€¤ `student` ãŒæŒ¿å…¥ã•ã‚Œã€ä»¥å‰ã®å€¤ã¯ã™ã¹ã¦ä¸Šæ›¸ãã•ã‚Œã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€å­¦ç”ŸãŒå‘¼ã³å‡ºã™å¿…è¦ãŒã‚ã‚‹ `register` é–¢æ•°ã‚’ä½œæˆã—ã€é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®æƒ…å ±ã‚’æä¾›ã§ãã¾ã™ã€‚

```motoko
public shared ({ caller }) func register(name : Text, age : Nat, favoriteLanguage : Text) : async () {
    if(Principal.isAnonymous(caller)){
        // We don't want to register the anonymous identity
        return;
    };
    let student : Student = {
        name;
        age;
        favoriteLanguage;
        graduate = false;  
    };
    map.put(caller, student);
};
```

Once a value has been inserted in the `map`, we can access it using the `.get()` method.  
å€¤ã‚’ `map` ã«æŒ¿å…¥ã—ãŸã‚‰ã€`.get()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ãã®å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```motoko
map.get(principal);
```
This will return an optional value `?Student` associated with the provided principal. We can use this method to create a `getStudent` `query` function that would return information on students.  
ã“ã‚Œã¯ã€æŒ‡å®šã•ã‚ŒãŸæ ¡é•·ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸ optional ãªå€¤ `?Student` ã‚’è¿”ã—ã¾ã™ã€‚ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã—ã¦ã€ç”Ÿå¾’ã®æƒ…å ±ã‚’è¿”ã™ `getStudent` `query` é–¢æ•°ã‚’ä½œæˆã§ãã¾ã™ã€‚
```motoko
public query func getStudent(p : Principal) : async ?Student {
map.get(p);
};
```
We can delete a value from the `map` by using the `.delete()` or `remove()` methods.  
`.delete()` ã¾ãŸã¯ `remove()` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã¨ã€`map` ã‹ã‚‰å€¤ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```motoko
map.delete(principal);   // Delete but doesn't return the value / å‰Šé™¤ã¯ã™ã‚‹ãŒã€å€¤ã¯è¿”ã•ãªã„
let oldValue = map.remove(principal);   // Delete but returns the value / å‰Šé™¤ã™ã‚‹ãŒã€å€¤ã‚’è¿”ã™
```
It is possible to iterate over the map:  
ãƒãƒƒãƒ—ã‚’ç¹°ã‚Šè¿”ã—è¡¨ç¤ºã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ï¼š
- You can iterate over the keys with `.keys()`.
- .keys()`ã§ã‚­ãƒ¼ã‚’åå¾©å‡¦ç†ã§ãã¾ã™ã€‚
- You can iterate over the values with `.vals()`.
- .vals()`ã§å€¤ã‚’åå¾©å‡¦ç†ã§ãã¾ã™ã€‚
- You can iterate over both with `.entries()`.
- .entries()`ã‚’ä½¿ãˆã°ã€ä¸¡æ–¹ã‚’ç¹°ã‚Šè¿”ã—å‡¦ç†ã§ãã¾ã™ã€‚
