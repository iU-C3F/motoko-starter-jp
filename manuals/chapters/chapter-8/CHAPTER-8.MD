# Chapter 8: Advanced Types.ã€€/ ç¬¬8ç« ï¼šé«˜åº¦ãªå‹
## â“ Optional types / Optional å‹
In Motoko, as in many other programming languages, there is a special value called `null` used to represent the absence of a result. This is helpful when indicating that a function returns nothing. The value `null` is of type `Null`, which only contains one value: `null`.  
Motoko ã§ã¯ã€ä»–ã®å¤šãã®ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã¨åŒæ§˜ã«ã€çµæœãŒãªã„ã“ã¨ã‚’è¡¨ã™ãŸã‚ã«`null`ã¨å‘¼ã°ã‚Œã‚‹ç‰¹åˆ¥ãªå€¤ãŒå­˜åœ¨ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€é–¢æ•°ãŒä½•ã‚‚è¿”ã•ãªã„ã“ã¨ã‚’ç¤ºã™ã¨ãã«ä¾¿åˆ©ã§ã™ã€‚å€¤ `null` ã¯ `Null` å‹ã§ã‚ã‚Šã€`null` ã¨ã„ã†ï¼‘ã¤ã®å€¤ã®ã¿ã‚’å«ã¿ã¾ã™ã€‚

Consider an array of names called `names` and a function called `find_name` that takes a list of names as input and returns the index of the first occurrence of the name in the array. If the name is not found, the function should return `null` instead of an index. This way, the function indicates that it did not find the name without producing an error.  
`names`ã¨ã„ã†åå‰ã®é…åˆ—ã¨ã€åå‰ã®ãƒªã‚¹ãƒˆã‚’å…¥åŠ›ã¨ã—ã¦å—ã‘å–ã‚Šã€é…åˆ—ã®ä¸­ã§åå‰ãŒæœ€åˆã«å‡ºç¾ã™ã‚‹ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™ `find_name` ã¨ã„ã†é–¢æ•°ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚åå‰ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸå ´åˆã€ã“ã®é–¢æ•°ã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ä»£ã‚ã‚Šã« `null` ã‚’è¿”ã•ãªã‘ã‚Œã°ãªã‚Šã¾ã›ã‚“ã€‚ã“ã®ã‚ˆã†ã«ã™ã‚‹ã¨ã€é–¢æ•°ã¯ã‚¨ãƒ©ãƒ¼ã‚’å‡ºã•ãšã«åå‰ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚

The following code is not valid in Motoko:  
ä»¥ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã¯ã€Motoko ã§ã¯ç„¡åŠ¹ã§ã™ï¼š
```motoko
let names : [Text] = ["Motoko", "Rust", "JavaScript", "TypeScript"];
public func find_name(name : Text) : async Nat {
    var index : Nat = 0;
    for(language in names.vals()){
        if (language == name){
            return index;
        };
        index +=1;
    };
    return null; // We haven't found any match so we return null. / ä¸€è‡´ã™ã‚‹ã‚‚ã®ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã€null ã‚’è¿”ã—ã¾ã™ã€‚
};
````
Motoko throws an error because `null` is not of type `Nat`. To indicate that a function may return either a `Nat` value or `null`, we need a way to express that the function's return type can be one of two possibilities. The specific return value of the function depends on the input, which is unknown in advance, so we cannot predict if the function will return a `Nat` or `null` until it is executed.  
Motoko ã¯ `null` ãŒ `Nat` å‹ã§ãªã„ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã‚’æŠ•ã’ã¾ã™ã€‚é–¢æ•°ãŒ `Nat` å€¤ã‹ `null` ã®ã©ã¡ã‚‰ã‹ã‚’è¿”ã™å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã‚’ç¤ºã™ã«ã¯ã€é–¢æ•°ã®æˆ»ã‚Šå€¤ã®å‹ãŒï¼’ã¤ã®å¯èƒ½æ€§ã®ã©ã¡ã‚‰ã‹ã§ã‚ã‚‹ã“ã¨ã‚’è¡¨ç¾ã™ã‚‹æ–¹æ³•ãŒå¿…è¦ã§ã™ã€‚é–¢æ•°ã®å…·ä½“çš„ãªæˆ»ã‚Šå€¤ã¯å…¥åŠ›ã«ä¾å­˜ã—ï¼Œãã‚Œã¯äº‹å‰ã«åˆ†ã‹ã‚‰ãªã„ã®ã§ï¼Œé–¢æ•°ãŒ `Nat` ã‚’è¿”ã™ã‹ `null` ã‚’è¿”ã™ã‹ã¯å®Ÿè¡Œã•ã‚Œã‚‹ã¾ã§äºˆæ¸¬ã§ãã¾ã›ã‚“ã€‚

We can use an optional type, `?T`, to express this. In our case, we would use `?Nat`. We can rewrite our code using this notation:  
ã“ã‚Œã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã«ã€Optional å‹ã§ã‚ã‚‹ `?T` ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚ç§ãŸã¡ã®å ´åˆã¯ã€`?Nat`ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã“ã®è¨˜æ³•ã§ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãç›´ã™ã“ã¨ãŒã§ãã¾ã™ï¼š
```motoko
let names : [Text] = ["Motoko", "Rust", "JavaScript", "TypeScript"];
public func find_name(name : Text) : async ?Nat {
    var index : Nat = 0;
    for(language in names.vals()){
        if (language == name){
            return ?index;
        };
        index +=1;
    };
    return null; // We haven't found any match so we return null. / ä¸€è‡´ã™ã‚‹ã‚‚ã®ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã€null ã‚’è¿”ã—ã¾ã™ã€‚
};
```

The optional type, indicated by `?`, can be used with any other type, such as `?Text`, `?Int`, `?Bool`, and more.  
`?` ã§ç¤ºã•ã‚Œã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³å‹ã¯ã€`?Text`ã€`?Int`ã€`?Bool`ãªã©ã€ä»–ã®ã©ã®å‹ã§ã‚‚ä½¿ãˆã¾ã™ã€‚

Also, the optional type is often used with the `switch/case` pattern in Motoko. This pattern allows you to handle an optional value and execute different parts of your code depending on whether the input value is `null` or not. You can use the `switch/case` pattern to check if an optional value is present and perform different actions based on that, resulting in more elegant and safer code.  
ã¾ãŸã€optional å‹ã¯ Motoko ã® `switch/case` ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ä¸€ç·’ã«ä½¿ã‚ã‚Œã‚‹ã“ã¨ãŒå¤šã„ã§ã™ã€‚ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã¯ã€ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å€¤ã‚’æ‰±ã„ã€å…¥åŠ›å€¤ãŒ `null` ã‹ã©ã†ã‹ã«å¿œã˜ã¦ã‚³ãƒ¼ãƒ‰ã®ç•°ãªã‚‹éƒ¨åˆ†ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚`switch/case` ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ä½¿ã£ã¦ optional å€¤ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ãã‚Œã«åŸºã¥ã„ã¦ç•°ãªã‚‹ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã™ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆã§å®‰å…¨ãªã‚³ãƒ¼ãƒ‰ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚
```motoko
public func handle_null_value(n : ?Nat) : async Text {
    switch(n) {
        // Check if n is null 
        case(null){
            return ("The argument is null"); 
        };
        case(? something){
            return ("The argument is : " # Nat.toText(something));
        };
    };
};
```
Lastly, the Base library provides an **Option** module for operating on optional values. For example, you can use the `Option.get()` function to unwrap an optional value with a default value:  
æœ€å¾Œã«ã€Base ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã¯ã€optional å€¤ã‚’æ“ä½œã™ã‚‹ãŸã‚ã® **Option** ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æä¾›ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€`Option.get()` é–¢æ•°ã‚’ä½¿ã£ã¦ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’æŒã¤ã‚ªãƒ—ã‚·ãƒ§ãƒŠãƒ«å€¤ã‚’ã‚¢ãƒ³ãƒ©ãƒƒãƒ—ã§ãã¾ã™ï¼š
```motoko
import Option "mo:base/Option";
actor {
    public func always_return_a_nat(n : ?Nat) : async Nat {
        return(Option.get(n, 0))
    };
}
```
This function takes a `?Nat` as input and returns a `Nat`. If you provide a `Nat` as input, it will return the same value. However, if you provide `null`, it will return the default value, set to 0.  
ã“ã®é–¢æ•°ã¯ `?Nat` ã‚’å…¥åŠ›ã¨ã—ã¦å—ã‘å–ã‚Šã€`Nat` ã‚’è¿”ã™ã€‚å…¥åŠ›ã¨ã—ã¦ `Nat` ã‚’æŒ‡å®šã—ãŸå ´åˆã¯ã€åŒã˜å€¤ã‚’è¿”ã—ã¾ã™ã€‚ã—ã‹ã—ã€`null`ã‚’å…¥åŠ›ã—ãŸå ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å€¤ã§ã‚ã‚‹ 0 ã‚’è¿”ã—ã¾ã™ã€‚
## ğŸ‘¤ Generic Type / Generic å‹
A generic type, usually written as `T`, allows you to write functions and code that can adapt to different types. When we talk about `T`, it refers to **whatever type you want**. This means that you can create a single function or class that can handle multiple types of inputs or data, without having to write separate code for each type.  
é€šå¸¸ `T` ã¨æ›¸ã‹ã‚Œã‚‹ generic å‹ã¯ã€ç•°ãªã‚‹å‹ã«é©å¿œã§ãã‚‹é–¢æ•°ã‚„ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ãã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚`T` ã«ã¤ã„ã¦è©±ã™ã¨ãã€ãã‚Œã¯ **ã‚ãªãŸãŒæœ›ã‚€ã©ã‚“ãªå‹ã§ã‚‚** ã‚’æŒ‡ã—ã¾ã™ã€‚ã¤ã¾ã‚Šã€ãã‚Œãã‚Œã®å‹ã«å¯¾ã—ã¦åˆ¥ã€…ã®ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã‹ãªãã¦ã‚‚ã€è¤‡æ•°ã®å…¥åŠ›ã‚„ãƒ‡ãƒ¼ã‚¿ã‚’æ‰±ãˆã‚‹é–¢æ•°ã‚„ã‚¯ãƒ©ã‚¹ã‚’ï¼‘ã¤ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

Let's imagine that we have a task at hand - to determine if the size of an array is even or not. We're going to write a function called `isArrayEven` that takes an array as an input and returns a `Bool` value indicating whether the size of that array is even or not.  
ã‚ã‚‹é…åˆ—ã®ã‚µã‚¤ã‚ºãŒå¶æ•°ã‹ã©ã†ã‹ã‚’åˆ¤æ–­ã™ã‚‹ã€ã¨ã„ã†ã‚¿ã‚¹ã‚¯ãŒã‚ã‚‹ã¨ã—ã¾ã™ã€‚ã“ã“ã§ã¯ã€é…åˆ—ã‚’å…¥åŠ›ã¨ã—ã¦å—ã‘å–ã‚Šã€ãã®é…åˆ—ã®ã‚µã‚¤ã‚ºãŒå¶æ•°ã‹ã©ã†ã‹ã‚’ç¤ºã™ `Bool` å€¤ã‚’è¿”ã™ `isArrayEven` ã¨ã„ã†é–¢æ•°ã‚’ä½œæˆã™ã‚‹ã“ã¨ã«ã—ã¾ã™ã€‚
```motoko
public func isArrayEven(array : [Nat]) : async Bool {
    let size = array.size();
    if(size % 2 == 0){
        return true;
    } else {
        return false;
    };
};
```
This function works as intended, but is limited to arrays filled with `Nat`. So, what if we want to check the size of an array filled with `Text` or `Int`?  
ã“ã®é–¢æ•°ã¯æ„å›³ã—ãŸã¨ãŠã‚Šã«å‹•ä½œã—ã¾ã™ãŒã€`Nat`ã§åŸ‹ã‚ã‚‰ã‚ŒãŸé…åˆ—ã«é™å®šã•ã‚Œã¾ã™ã€‚ã§ã¯ã€`Text`ã‚„`Int`ã§åŸ‹ã‚ã‚‰ã‚ŒãŸé…åˆ—ã®ã‚µã‚¤ã‚ºã‚’ç¢ºèªã—ãŸã„å ´åˆã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã—ã‚‡ã†ã‹ã€‚<br>
One approach would be to create a separate function for each possible type:  
ä¸€ã¤ã®æ–¹æ³•ã¨ã—ã¦ã€å¯èƒ½æ€§ã®ã‚ã‚‹ã‚¿ã‚¤ãƒ—ã”ã¨ã«åˆ¥ã®é–¢æ•°ã‚’ä½œæˆã™ã‚‹ã“ã¨ãŒè€ƒãˆã‚‰ã‚Œã¾ã™ï¼š
- `isArrayEvenNat`
- `isArrayEvenText`
- `isArrayEvenInt` 

As you can imagine, this quickly becomes hard to manage and maintain. A better solution is to utilize the power of generics. With generics, we can write a single function that works for any type of array. It's a more elegant and efficient way to solve the problem. So, let's embrace our new friend - generics - and make our code more dynamic and flexible!  
æƒ³åƒã§ãã‚‹ã‚ˆã†ã«ã€ã“ã‚Œã¯ã™ãã«ç®¡ç†ã¨ç¶­æŒãŒé›£ã—ããªã‚Šã¾ã™ã€‚ãã“ã§ã€genericsã€€ã®åŠ›ã‚’æ´»ç”¨ã™ã‚‹ã®ãŒã‚ˆã„ã§ã—ã‚‡ã†ã€‚generics ã‚’ä½¿ãˆã°ã€ã©ã‚“ãªã‚¿ã‚¤ãƒ—ã®é…åˆ—ã«ã‚‚å¯¾å¿œã™ã‚‹é–¢æ•°ã‚’ï¼‘ã¤æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã‚Œã¯ã€ã‚ˆã‚Šã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆã§åŠ¹ç‡çš„ãªå•é¡Œè§£æ±ºæ–¹æ³•ã§ã™ã€‚ãã‚Œã§ã¯ã€æ–°ã—ã„å‹äººã§ã‚ã‚‹ generics ã‚’å—ã‘å…¥ã‚Œã¦ã€ã‚³ãƒ¼ãƒ‰ã‚’ã‚ˆã‚Šãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã§æŸ”è»Ÿãªã‚‚ã®ã«ã—ã¾ã—ã‚‡ã†ï¼
```motoko
func isArrayEven<T>(array : [T]) : Bool {
    let size = array.size();
    if(size % 2 == 0){
        return true;
    } else {
        return false;
    };
};
```
Notice `<T>` following the name of the function. It means that this function now depends on the type of `T`. We need to specify the type of `T` when we want to use the function.  
é–¢æ•°åã®å¾Œã«ç¶šã `<T>` ã«æ³¨ç›®ã—ã¦ãã ã•ã„ã€‚ã“ã‚Œã¯ã€ã“ã®é–¢æ•°ãŒ `T` ã®å‹ã«ä¾å­˜ã™ã‚‹ã“ã¨ã‚’æ„å‘³ã—ã¦ã„ã¾ã™ã€‚ã“ã®é–¢æ•°ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«ã¯ã€`T` ã®å‹ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
```motoko
let array : [Nat] = [1,2,3,4];
let bool : Boolean = isArrayEvent<Nat>(array); // Replace T with the actual type when you use the function. 
```

We've  already used generics when playing with `Buffer` & `Array` without talking about it.  
ç§ãŸã¡ã¯ã™ã§ã« `Buffer` ã¨ `Array` ã‚’æ‰±ã†ã¨ãã« generics ã‚’è©±é¡Œã«ã™ã‚‹ã“ã¨ãªãä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
- The type `Buffer<T>` is a generic class and we need to provide a type when creating a new buffer.
- `Buffer<T>` å‹ã¯ generics ã‚¯ãƒ©ã‚¹ã§ã‚ã‚Šã€æ–°è¦ã«ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã™ã‚‹éš›ã«ã¯å‹ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
    ```motoko
    let b = Buffer.Buffer<Nat>(2);
    ```

- `Array.append<T>` is a generic function and we need to provide the type of the elements of the arrays we are concatening.
- `Array.append<T>` ã¯ generics é–¢æ•°ã§ã‚ã‚Šã€é€£çµã™ã‚‹é…åˆ—ã®è¦ç´ ã®å‹ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚
    ```motoko
    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];
    Array.append<Nat>(array1, array2) // [1, 2, 3, 4, 5, 6];
    ```
## ğŸ¤« Shared types / Shared å‹
When information is sent to or received from an `actor` in Motoko, it uses specific data types called **shared types**. These **shared types** are used in `public` functions that can be accessed by other actors. So, **shared types** are the kinds of data that can be used as input or output for these public functions, allowing different actors to communicate with each other.  
Motoko ã® `actor` ã«æƒ…å ±ã‚’é€ã£ãŸã‚Šå—ã‘å–ã£ãŸã‚Šã™ã‚‹ã¨ãã€**shared å‹** ã¨å‘¼ã°ã‚Œã‚‹ç‰¹å®šã®ãƒ‡ãƒ¼ã‚¿å‹ãŒä½¿ã‚ã‚Œã¾ã™ã€‚ã“ã® **shared å‹** ã¯ã€ä»–ã® actor ãŒã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹`public` é–¢æ•°ã§ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ã¤ã¾ã‚Šã€**shared å‹** ã¯ã€ã“ã‚Œã‚‰ã® public é–¢æ•°ã®å…¥åŠ›ã¾ãŸã¯å‡ºåŠ›ã¨ã—ã¦ä½¿ç”¨ã§ãã‚‹ãƒ‡ãƒ¼ã‚¿ã®ç¨®é¡ã§ã‚ã‚Šã€ç•°ãªã‚‹ã‚¢ã‚¯ã‚¿ãƒ¼ãŒäº’ã„ã«é€šä¿¡ã™ã‚‹ã“ã¨ã‚’å¯èƒ½ã«ã—ã¾ã™ã€‚<br/>

If we try to deploy [the following actor](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=2185064550):  
[ä¸‹è¨˜ã® actor](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=2185064550) ã‚’é…ç½®ã—ã‚ˆã†ã¨ã™ã‚‹ã¨:
```motoko
actor {
  var mutableArray : [var Nat] = [var 1, 3, 5, 7]; 

  public func showArray() : async [var Nat] {
    return mutableArray
  };
}
```
We will encounter the following error: `Error in file Main.mo:3:28 shared function has non-shared return type [var Nat] type [var Nat] is or contains non-shared type var Nat`.  
æ¬¡ã®ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ï¼š `Error in file Main.mo:3:28 shared function has non-shared return type [var Nat] type [var Nat] is or contains non-shared type var Nat`.

A very important rule to remember: **every mutable state is always private to an actor.**  
è¦šãˆã¦ãŠãã¹ãéå¸¸ã«é‡è¦ãªãƒ«ãƒ¼ãƒ«ã§ã™ï¼š **ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãªã‚¹ãƒ†ãƒ¼ãƒˆã¯ã€å¸¸ã« actor ã® private ãªã‚¹ãƒ†ãƒ¼ãƒˆã§ã™ã€‚**

To put it short - anything that you can modify in your the state of your canister should be consider private and you won't be able to share it with other actors.  
ç°¡å˜ã«è¨€ã†ã¨ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚’å¤‰æ›´ã§ãã‚‹ã‚‚ã®ã¯ã™ã¹ã¦ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãªã‚‚ã®ã¨è€ƒãˆã€ä»–ã®ã‚¢ã‚¯ã‚¿ãƒ¼ã¨å…±æœ‰ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚<br/>

<p align="center"> <img src="./assets/mutable_state_actor.png" width="800px" style="border: 2px solid black;"></p>
<p align="center"> If it's a var your can't share it outside!</p>
<p align="center">var ã®å ´åˆã€å¤–ã§å…±æœ‰ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼</p>

> For a complete overview of all the shared types, [refer to the Motoko Book](https://web3.motoko-book.dev/internet-computer-programming-concepts/async-data/shared-types.html?highlight=Shared%20types#shared-types).

> å…¨ shared å‹ã®æ¦‚è¦ã«ã¤ã„ã¦ã¯ã€[Motoko Book](https://web3.motoko-book.dev/internet-computer-programming-concepts/async-data/shared-types.html?highlight=Shared%20types#shared-types) ã‚’ã”å‚ç…§ãã ã•ã„ã€‚

## ğŸ”ƒ Recursive types / Recursive å‹
Read [this section](https://web3.motoko-book.dev/advanced-types/recursive-types.html) of the Motoko Book.  
Motoko Book ã® [ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³](https://web3.motoko-book.dev/advanced-types/recursive-types.html) ã‚’ãŠèª­ã¿ãã ã•ã„ã€‚