# Chapter 7: Non-primitives Types. / éãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹
## ğŸ‘¯ Tuples / ã‚¿ãƒ—ãƒ«
Tuples are basic units that can encompass multiple elements. While the elements can vary in data type, once declared, the number and type of elements in a tuple cannot be altered. For instance, you could make a tuple that holds a student's name, age & favorite programming language.  
ã‚¿ãƒ—ãƒ«ã¯ã€è¤‡æ•°ã®è¦ç´ ã‚’åŒ…å«ã™ã‚‹ã“ã¨ãŒã§ãã‚‹åŸºæœ¬å˜ä½ã§ã™ã€‚è¦ç´ ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯æ§˜ã€…ã§ã™ãŒã€ä¸€åº¦å®£è¨€ã—ãŸã‚¿ãƒ—ãƒ«ã®è¦ç´ ã®æ•°ã¨å‹ã¯å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚ä¾‹ãˆã°ã€ç”Ÿå¾’ã®åå‰ã€å¹´é½¢ã€å¥½ããªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’ä¿æŒã™ã‚‹ã‚¿ãƒ—ãƒ«ã‚’ä½œæˆã§ãã¾ã™ã€‚
```motoko
type Student = (Text, Nat, Text);
let me : Student  = ("Bob Smith", 25, "Motoko");
```
In more complex situations, we would create our own object with named fields, making it more readable.  
ã‚ˆã‚Šè¤‡é›‘ãªçŠ¶æ³ã§ã¯ã€åå‰ä»˜ããƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ç‹¬è‡ªã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã—ã€ã‚ˆã‚Šèª­ã¿ã‚„ã™ã„ã‚‚ã®ã«ã—ã¾ã™ã€‚

The empty tuple type `()` is called the `unit` type. It is usually used as return type for function that returns nothing.  
ç©ºã®ã‚¿ãƒ—ãƒ«å‹ `()` ã¯ `unit` å‹ã¨å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã‚Œã¯é€šå¸¸ã€ä½•ã‚‚è¿”ã•ãªã„é–¢æ•°ã®æˆ»ã‚Šå€¤å‹ã¨ã—ã¦ä½¿ã‚ã‚Œã¾ã™ã€‚
```motoko
public func print(t : Text) : async () {
    Debug.print(t);
};
```
## ğŸ¨ Objects / ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
Objects are more readable than tuples since each field has a name. The  different fields are also each assigned a type which cannot be modified once declared.  
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã€å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åå‰ãŒã¤ã„ã¦ã„ã‚‹ãŸã‚ã€ã‚¿ãƒ—ãƒ«ã‚ˆã‚Šã‚‚èª­ã¿ã‚„ã™ããªã£ã¦ã„ã¾ã™ã€‚ã¾ãŸã€ç•°ãªã‚‹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ãã‚Œãã‚Œå‹ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¦ãŠã‚Šã€ä¸€åº¦å®£è¨€ã™ã‚‹ã¨å¤‰æ›´ã§ãã¾ã›ã‚“ã€‚   
 Let's define an object called `student`, which contains 4 fields: 
 ã“ã“ã§ã¯ã€4ã¤ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’æŒã¤ `student` ã¨ã„ã†ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å®šç¾©ã—ã¾ã™ï¼š 
 - name which is a `Text` indicating the name of the student.
 - name ã¯ç”Ÿå¾’ã®åå‰ã‚’ç¤ºã™ `Text` ã§ã™ã€‚
 - age which is a `Nat` indicating the age of the student.
 - age ã¯ç”Ÿå¾’ã®å¹´é½¢ã‚’ç¤ºã™ `Nat` ã§ã™ã€‚
 - favoriteLanguage which is a `Text` indicating the favorite programming language of the student.
 - favoriteLanguage ã¯ã€å­¦ç”Ÿã®å¥½ããªãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã‚’ç¤ºã™ `Text` ã§ã™ã€‚
 - graduate which is a `Bool` indicating if the students has already graduated from the Motoko Bootcamp. 
 - graduate ã¯ã€ãã®å—è¬›ç”ŸãŒã™ã§ã« Motoko ãƒ–ãƒ¼ãƒˆã‚­ãƒ£ãƒ³ãƒ—ã‚’å’æ¥­ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ `Bool` ã§ã™ã€‚

```motoko
let student = {
    name = "John";
    age = 35;
    favoriteLanguage = "Motoko";
    graduate = true;
};
```
Similar to other variables in Motoko, objects can be mutable or immutable. The object we've just defined is immutable, once the fields have been assigned a value they cannot be modified.  
Motoko ã®ä»–ã®å¤‰æ•°ã¨åŒæ§˜ã«ã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚‚ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã¨ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ãŒã‚ã‚Šã¾ã™ã€‚å…ˆã»ã©å®šç¾©ã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§ã€ä¸€åº¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«å€¤ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸã‚‰å¤‰æ›´ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚

```motoko
let student = {
    name = "John";
    age = 35;
    favoriteLanguage = "Motoko";
    graduate = true;
};
student.age += 1;  
```
This code will throw an error `expected mutable assignment target`.  
ã“ã®ã‚³ãƒ¼ãƒ‰ã§ã¯ã€`expected mutable assignment target` ã¨ã„ã†ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚  

To create an object that can be modified, we must use the `var` keyword in the field definition. Let's modify the previous example so that only the student's age can be changed, while the other fields remain constant.  
å¤‰æ›´å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã«ã¯ã€ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®šç¾©ã« `var` ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚å‰ã®ä¾‹ã‚’ä¿®æ­£ã—ã¦ã€ç”Ÿå¾’ã®å¹´é½¢ã ã‘ã‚’å¤‰æ›´ã§ãã‚‹ã‚ˆã†ã«ã—ã€ä»–ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ä¸€å®šã®ã¾ã¾ã«ã—ã¦ãŠãã¾ã—ã‚‡ã†ã€‚
```motoko
let student = {
    name = "John";
    var age = 35;
    favoriteLanguage = "Motoko";
    graduate = true;
};
student.age += 1; 
```
Objects are often assigned types. In this case we need to create **custom type**.  Let's define a type called `Student` which corresponds the object we've previously created.  
ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ã€ã—ã°ã—ã°å‹ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚Œã¾ã™ã€‚ã“ã®å ´åˆã€**ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒ—** ã‚’ä½œæˆã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ ã“ã“ã§ã¯ã€å…ˆã«ä½œæˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾å¿œã™ã‚‹ `Student` ã¨ã„ã†å‹ã‚’å®šç¾©ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
```motoko
type Student = {
    name : Text;
    age : Nat;
    favoriteLanguage : Text;
    graduate : Bool;
};
```

## ğŸŒˆ Variants / ãƒãƒªã‚¢ãƒ³ãƒˆ
A variant allows you to create a type that contains different cases. A value from the variant type represents one value that is exactly one of the given cases, or tags. Let's define a variant type for a `Vehicle` which can be either a car, a moto or a plane.  
ãƒãƒªã‚¢ãƒ³ãƒˆã§ã¯ã€ç•°ãªã‚‹ã‚±ãƒ¼ã‚¹ã‚’å«ã‚€ã‚¿ã‚¤ãƒ—ã‚’ä½œæˆã§ãã¾ã™ã€‚ãƒãƒªã‚¢ãƒ³ãƒˆå‹ã®å€¤ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸã‚±ãƒ¼ã‚¹ã€ã¤ã¾ã‚Šã‚¿ã‚°ã®ã†ã¡ã®ã¡ã‚‡ã†ã©ï¼‘ã¤ã§ã‚ã‚‹ï¼‘ã¤ã®å€¤ã‚’è¡¨ã—ã¾ã™ã€‚ä¾‹ãˆã°ã€è»Šã€ãƒã‚¤ã‚¯ã€é£›è¡Œæ©Ÿã®ã„ãšã‚Œã‹ã«ãªã‚‹ `Vehicle` ã®ãƒãƒªã‚¢ãƒ³ãƒˆã‚¿ã‚¤ãƒ—ã‚’å®šç¾©ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

```motoko
type Vehicle = {
    #Car;
    #Moto;
    #Plane;
};
```
Each tag can be associated it's own custom type.  
å„ã‚¿ã‚°ã¯ã€ç‹¬è‡ªã®ã‚«ã‚¹ã‚¿ãƒ ã‚¿ã‚¤ãƒ—ã«é–¢é€£ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```motoko
type Car = { make : Text; model : Text; year : Nat; color: Text };
type Moto = { make : Text; model : Text; year : Nat; type : Text };
type Plane = { make : Text; model : Text; year : Nat; seats : Nat };

type Vehicle = {
    #Car : Car;
    #Moto : Moto;
    #Plane : Plane;
};
```

Variants are often used with `switch/case`, which allows to perform control flow on a variant object.  
ãƒãƒªã‚¢ãƒ³ãƒˆã¯ã—ã°ã—ã° `switch/case` ã¨å…±ã«ä½¿ç”¨ã•ã‚Œã€ãƒãƒªã‚¢ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚’å®Ÿè¡Œã§ãã¾ã™ã€‚
```motoko
public func start(v : Vehicle) : async Text {
    switch(v){
        case(#Car(car)){
            // We can access the car object. For instance we can access the make field by using car.make / car ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ä¾‹ãˆã°ã€car.make ã‚’ä½¿ã£ã¦ make ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
            let make = car.age;
            return("Vroom ğŸï¸");
        };
        case(#Moto(m)){
            // We can give the object any name that is convenient. In this case we can access the type by using m.type.
            let type = m.type; / ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯éƒ½åˆã®è‰¯ã„åå‰ã‚’ä»˜ã‘ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚ã“ã®å ´åˆã€m.type ã‚’ä½¿ã†ã“ã¨ã§ type ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
            let type = m.typeï¼›
              return("Roar ğŸï¸");
        };
        case(#Plane(x)){
            // Here we go again.. we can access the number of seats by using x.seats / ã¾ãŸã¾ãŸã§ã™ã€‚x.seats ã‚’ä½¿ã£ã¦åº§å¸­æ•°ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
            let seats = x.seats;
             return("Whoosh ğŸ›«");
        };
    };
};
```
## âœï¸ Mutable Arrays / ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«é…åˆ—
Read [this section](https://web3.motoko-book.dev/common-programming-concepts/types/mutable-arrays.html?highlight=Mutable%20arrays#mutable-arrays) from the Motoko Book.  
Motoko ãƒ–ãƒƒã‚¯ã® [ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³](https://web3.motoko-book.dev/common-programming-concepts/types/mutable-arrays.html?highlight=Mutable%20arrays#mutable-arrays) ã‚’èª­ã‚“ã§ãã ã•ã„ã€‚
## â­ï¸ Iterators / ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿
Read [this section](https://web3.motoko-book.dev/base-library/utils/iter.html?highlight=Itera#iteriterate) from the Motoko Book.  
Motoko ãƒ–ãƒƒã‚¯ã® [ã“ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³](https://web3.motoko-book.dev/base-library/utils/iter.html?highlight=Itera#iteriterate) ã‚’èª­ã‚“ã§ãã ã•ã„ã€‚
