# Chapter 3: Primitive Types in Motoko. / ç¬¬3ç«  Motoko ãŠã‘ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹
Primitive types are fundamental core data types that are not composed of more fundamental types. <br/>

ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã¯ã€ã‚ˆã‚ŠåŸºæœ¬çš„ãªå‹ã‹ã‚‰æ§‹æˆã•ã‚Œãªã„åŸºæœ¬çš„ãªã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿å‹ã§ã‚ã‚‹ã€‚<br/>

Primitive types are all the types that do not need to be imported before they can be used in type annotation.  
ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å‹ã¯ã€å‹ã‚¢ãƒãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ã§ä½¿ç”¨ã™ã‚‹å‰ã«ã‚¤ãƒ³ãƒãƒ¼ãƒˆã™ã‚‹å¿…è¦ã®ãªã„ã™ã¹ã¦ã®å‹ã§ã™ã€‚
<p align="center"> <img src="./assets/motoko_primitives_types.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> A few primitive types in Motoko</p>
<p align="center">Motoko ã®æ•°å°‘ãªã„ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒ—</p>

## ğŸ”¢ Nat
`Nat` is used for **unbounded** natural numbers (1,2,3,4,...â™¾ï¸). By default all positive whole numbers are casted to `Nat`.  
`Nat` ã¯ **ç„¡é™ã®** è‡ªç„¶æ•° (1,2,3,4,...â™¾ï¸) ã«å¯¾ã—ã¦ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã¯ã€ã™ã¹ã¦ã®æ­£ã®æ•´æ•°ãŒ `Nat` ã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚Œã¾ã™ã€‚

```motoko
let n : Nat = 1;
```
Is equivalent to  
ã¯ã€ä¸‹è¨˜ã¨åŒç­‰ã§ã™ã€‚

```motoko
let n = 1; // Will be casted to Nat automatically è‡ªå‹•çš„ã«Natã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚Œã¾ã™
```
**Unbounded** means that value of type `Nat` will never [overflow](https://www.youtube.com/watch?v=WN8i5cwjkSE). The memory representation used will grow to accommodate any finite number. Motoko also has the concept of **bounded** natural numbers (`Nat8`, `Nat16`, `Nat32`, `Nat64`) that we will cover later. If you try to assign a negative number to a `Nat` the program will trap.  
**Unbounded** ã¯ `Nat` å‹ã®å€¤ãŒæ±ºã—ã¦ [ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼](https://www.youtube.com/watch?v=WN8i5cwjkSE) ã—ãªã„ã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚ä½¿ç”¨ã•ã‚Œã‚‹ãƒ¡ãƒ¢ãƒªè¡¨ç¾ã¯ã€ã©ã‚“ãªæœ‰é™ã®æ•°ã«ã‚‚å¯¾å¿œã§ãã‚‹ã‚ˆã†ã«æˆé•·ã—ã¾ã™ã€‚ã¾ãŸã€Motoko ã«ã¯ã€å¾Œã§å–ã‚Šä¸Šã’ã‚‹ **bounded** è‡ªç„¶æ•° (`Nat8`, `Nat16`, `Nat32`, `Nat64`) ã¨ã„ã†æ¦‚å¿µã‚‚ã‚ã‚Šã¾ã™ã€‚ã‚‚ã— `Nat` ã«è² ã®æ•°ã‚’ä»£å…¥ã—ã‚ˆã†ã¨ã™ã‚‹ã¨ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ãƒˆãƒ©ãƒƒãƒ—ã—ã¾ã™ã€‚

```motoko
let n : Nat = -1;
```
This line will return an error: `literal of type Int does not have expected type Nat`.  
ã“ã®è¡Œã¯ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã—ã¾ã™ï¼š`literal of type Int does not have expected type Nat`.

`Nat` supports usual operations:  
`Nat`ã¯é€šå¸¸ã®æ¼”ç®—ã«å¯¾å¿œã—ã¦ã„ã¾ã™ï¼š
- Addition: you can add two numbers using the addition operator `+`
- åŠ ç®—ï¼šåŠ ç®—æ¼”ç®—å­ `+` ã‚’ä½¿ã£ã¦2ã¤ã®æ•°å€¤ã‚’åŠ ç®—ã§ãã¾ã™ã€‚

```motoko
let a : Nat = 1 + 1;    // 2
```
- Subtraction: you can subtract two numbers using the subtraction operator `-`
- æ¸›ç®—ï¼šæ¸›ç®—æ¼”ç®—å­ `-` ã‚’ä½¿ã£ã¦ã€2ã¤ã®æ•°å€¤ã‚’å¼•ãç®—ã§ãã¾ã™ã€‚
```motoko
let a : Nat = 10 - 2;   // 8
```
> Be careful with substractions. `Nat` only plays with the positive numbers. If the result of the subtraction is less than zero, it won't fit. The value will no longer be of the `Nat` type and that could cause trouble if your program is expecting a value of the `Nat` type. 

> æ¸›ç®—ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚`Nat` ã¯æ­£ã®æ•°ã—ã‹æ‰±ãˆã¾ã›ã‚“ã€‚å¼•ãç®—ã®çµæœãŒ 0 ã‚ˆã‚Šã‚‚å°ã•ã„ã¨ã€é©åˆã—ã¾ã›ã‚“ã€‚ãã®å€¤ã¯ã‚‚ã¯ã‚„ `Nat` å‹ã§ã¯ãªããªã‚‹ã®ã§ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒ `Nat` å‹ã®å€¤ã‚’æœŸå¾…ã—ã¦ã„ã‚‹å ´åˆã€ãƒˆãƒ©ãƒ–ãƒ«ã®åŸå› ã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚

- Multiplication: you can multiply two numbers using the multiplication operator `*`
- ä¹—ç®—ï¼šä¹—ç®—æ¼”ç®—å­ `*` ã‚’ä½¿ã£ã¦ã€2ã¤ã®æ•°å€¤ã‚’æ›ã‘åˆã‚ã›ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
```motoko
let a : Nat = 10 * 10;  // 100
```
- Division and modulo: to divide two numbers, you can use the division operator `/` and to find the remainder of a divided by b, you can use the modulo operator `%`
- é™¤ç®—ã¨å‰°ä½™ï¼š2ã¤ã®æ•°ã‚’å‰²ã‚‹ã«ã¯é™¤ç®—æ¼”ç®—å­ `/` ã‚’ã€a ã‚’ b ã§å‰²ã£ãŸä½™ã‚Šã‚’æ±‚ã‚ã‚‹ã«ã¯å‰°ä½™æ¼”ç®—å­ `%` ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
```motoko
let a : Nat = 10 / 2;   // 5
let b : Nat = 3 % 2;    // 1
```
## â– Int.
Integers represents whole numbers that can be positive or negative. The same mathematical operations seen earlier (addition, multiplication, subtraction, division, and modulo) can be performed on both `Int` and `Nat`.  
æ•´æ•°ã¯æ­£è² ã®ã‚ã‚‹æ•´æ•°ã‚’è¡¨ã—ã¾ã™ã€‚å…ˆã«è¦‹ãŸã®ã¨åŒã˜æ•°å­¦çš„æ“ä½œï¼ˆåŠ ç®—ã€ä¹—ç®—ã€æ¸›ç®—ã€é™¤ç®—ã€å‰°ä½™ï¼‰ã¯ `Int` ã¨ `Nat` ã®ä¸¡æ–¹ã«å¯¾ã—ã¦è¡Œã†ã“ã¨ãŒã§ãã¾ã™ã€‚

```motoko
let i : Int = -3; 
let j : Int = 5;
```

> Since `Int` includes positive and negative whole numbers it includes all value of type `Nat`. We say that `Nat` is a subtype of `ÃŒnt`.
`ÃŒnt` is also an unbounded type and has bounded equivalents that we will cover later (`Int8`, `Int16`, `Int32`, `Int64`).

> `Int` ã¯æ­£è² ã®æ•´æ•°ã‚’å«ã‚€ã®ã§ã€ `Nat` å‹ã®å€¤ã¯ã™ã¹ã¦å«ã¾ã‚Œã¾ã™ã€‚`Nat` ã¯ `ÃŒnt` ã®éƒ¨åˆ†å‹ã§ã™ã€‚
ã¾ãŸã€`ÃŒnt` ã¯ unbounded å‹ã§ã‚ã‚Šã€å¾Œã§å–ã‚Šä¸Šã’ã‚‹ bounded å‹ã®ç­‰ä¾¡ç‰©ï¼ˆ`Int8`, `Int16`, `Int32`, `Int64`ï¼‰ãŒã‚ã‚Šã¾ã™ã€‚

## ğŸš¦ Bool.
A `Bool` is either `true` or `false`. `Bool` stands for boolean and this data type only contains two values.  
`Bool` ã¯ `true` ã‹ `false` ã®ã©ã¡ã‚‰ã‹ã§ã™ã€‚`Bool`ã¯booleanã®ç•¥ã§ã€ã“ã®ãƒ‡ãƒ¼ã‚¿å‹ã¯2ã¤ã®å€¤ã—ã‹æŒã¡ã¾ã›ã‚“ã€‚
```motoko
let light_on : Bool = true;
let door_open : Bool = false;
````

Booleans can be used and combined with logical operators:  
Boolean ã¯ã€è«–ç†æ¼”ç®—å­ã¨çµ„ã¿åˆã‚ã›ã¦ä½¿ç”¨ã§ãã¾ã™ï¼š

- `and`
```motoko
let result = false and false;   //false
```
```motoko
let result = true and false;    //false
```
```motoko
let result = false and true;    //false
```
```motoko
let result = true and true;     //true
```
- `or`
```motoko
let result = false or false;   //false
```
```motoko
let result = true or false;    //true
```
```motoko
let result = false or true;    //true
```
```motoko
let result = true or true;     //true
```
- `not`

```motoko
let result = not true;      //false
```
```motoko
let result = not false;     //true
```

`Nat` and `Int` supports comparison operators, which compare two integers and returns a `Bool`:  
`Nat` ã¨ `Int` ã¯æ¯”è¼ƒæ¼”ç®—å­ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãŠã‚Šã€2ã¤ã®æ•´æ•°ã‚’æ¯”è¼ƒã—ã¦ `Bool` ã‚’è¿”ã—ã¾ã™ï¼š 
- The `==` (equality) operator which indicates if two values are equal.
- 2ã¤ã®å€¤ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’ç¤ºã™ `==` (ç­‰å·) æ¼”ç®—å­ã§ã™ã€‚
- The `!=` (not equal) operator which indicates if two values are different.
- 2ã¤ã®å€¤ãŒç•°ãªã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™`!=`ï¼ˆnot equalï¼‰æ¼”ç®—å­ã€‚
- The `<` (less than) and `>` (more than) operators.
- æ¼”ç®—å­ `<` (less than) ã¨ `>` (more than) ã§ã™ã€‚
- The `<=` (less than or equal to) and `>=` (more than or equal to) operators.
- `<=`ï¼ˆä»¥ä¸‹ï¼‰ã€`>=`ï¼ˆä»¥ä¸Šï¼‰ã®æ¼”ç®—å­ã§ã™ã€‚

```motoko
3 < 5   // true
1 >= 1  // true
1 != 1  // false
2 == 10/5   // true
```
> The `==` operator is very different from the `=` operator. The first will test if two values are equal while the later will asign a value to a variable.

> æ¼”ç®—å­ `==` ã¯ `=` æ¼”ç®—å­ã¨å¤§ããç•°ãªã‚Šã¾ã™ã€‚å‰è€…ã¯2ã¤ã®å€¤ãŒç­‰ã—ã„ã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹ã‚‚ã®ã§ã€å¾Œè€…ã¯å€¤ã‚’å¤‰æ•°ã«ä»£å…¥ã™ã‚‹ã‚‚ã®ã§ã™ã€‚

## ğŸ’¬ Text
In Motoko, strings can be written surrounded by double quotes `"`  
Motokoã§ã¯ã€æ–‡å­—åˆ—ã‚’ãƒ€ãƒ–ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆ `"` ã§å›²ã‚“ã§è¨˜è¿°ã§ãã¾ã™ã€‚
```motoko
"Hello Motoko Bootcamp!"
```
The type for string is `Text`.  
æ–‡å­—åˆ—ã®å‹ã¯ `Text` ã§ã™ã€‚
```motoko
let welcomePhrase : Text = "Hello Motoko Bootcamp!";
```
We can use the concatenation operator `#` to join two `Text` together.  
é€£çµæ¼”ç®—å­ `#` ã‚’ä½¿ã£ã¦ã€2ã¤ã® `Text` ã‚’é€£çµã§ãã¾ã™ã€‚
```motoko
let firstName : Text = "Motoko";
let surname : Text = "Bootcamp";
let completeName : Text = firstName # surname;
```

We can access the size of a `Text` by calling the `.size()` method.  
`.size()`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€`Text`ã®ã‚µã‚¤ã‚ºã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚
```motoko
let name : Text = "Motoko";
let size = name.size()  // 6
```
## ğŸ”¤ Char
A value of type `Text` is actually composed of values from another type: `Char`. A `Text` is the concatenation of multiple characters. Characters are single-quote delimited `'`  
`Text`å‹ã®å€¤ã¯ã€å®Ÿéš›ã«ã¯åˆ¥ã®å‹ã®å€¤ã§æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼š `Char`ã§ã™ã€‚`Text` ã¯è¤‡æ•°ã® character ãŒé€£çµã—ãŸã‚‚ã®ã§ã™ã€‚character ã¯ã‚·ãƒ³ã‚°ãƒ«ã‚¯ã‚©ãƒ¼ãƒˆã§åŒºåˆ‡ã‚‰ã‚ŒãŸ `'` ã§ã™ã€‚
```motoko
let character_1 : Char = 'c';
let character_2 : Char = '8';
let character_3 : Char = 'âˆ';
```
`Char` are represented by their [Unicode code points](https://deliciousbrains.com/how-unicode-works/). We can use the `Char` module from the Base library to check the unicode value.  
`Char` ã¯ãã®[Unicode code points](https://deliciousbrains.com/how-unicode-works/)ã§è¡¨ã•ã‚Œã¾ã™ã€‚Unicodeã®å€¤ã‚’èª¿ã¹ã‚‹ã«ã¯ã€Baseãƒ©ã‚¤ãƒ–ãƒ©ãƒªã® `Char` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

```motoko
import Char "mo:base/Char";
import Debug "mo:base/Debug";
actor {
    let a : Char = 'a';
    Debug.print(debug_show(Char.toNat32(a)));   // 97
}
```
We can easily iterate over all the characters in a `Text`, by calling the `chars()` method. We can then use this iterator to create a `for` loop.  
`chars()`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ã§ã€ç°¡å˜ã« `Text` ã«å«ã¾ã‚Œã‚‹ã™ã¹ã¦ã®æ–‡å­—ã‚’åå¾©å‡¦ç†ã§ãã¾ã™ã€‚ãã—ã¦ã€ã“ã®ã‚¤ãƒ†ãƒ¬ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦ `for` ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã§ãã¾ã™ã€‚
```motoko
import Debug "mo:base/Debug";
import Char "mo:base/Char";
actor {
    let name : Text = "Motoko";
    for (letter in name.chars()){
        Debug.print(Char.toText(letter));
    };
};
```
> Notice how when we iterate `letter` is a `Char` and we need to convert it back to `Text` to use `Debug.print`.
The `Char` module also contains a few functions that can be used to test properties of characters:

> `letter` ãŒ `Char` ã§ã‚ã‚Šã€`Debug.print` ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã« `Text` ã«å¤‰æ›ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚
`Char`ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã«ã¯ã€æ–‡å­—ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒ†ã‚¹ãƒˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã§ãã‚‹ã„ãã¤ã‹ã®é–¢æ•°ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã™ï¼š

- `isDigit`
```motoko
Char.isDigit('9');  // true
```
- `isWhitespace`
```motoko
Char.isWhitespace('a'); // false
```
- `isLowercase`
```motoko
Char.isLowercase('c');  //  true
```
- `isUppercase`
```motoko
Char.isUppercase('D');  // true
```
- `isAlphabetic`
```motoko
Char.isAlphabetic('|'); // false
```
## ğŸ’¥ Float.
`Float` are numbers that have a decimal part.  
`Float`ã¯å°æ•°éƒ¨ã‚’æŒã¤æ•°å€¤ã§ã™ã€‚
```motoko
let pi = 3.14;
let e = 2.71;
```
If you want to use `Float` for whole numbers, you need to add the type descriptor otherwise they would automatically be casted to `ÃŒnt` or `Nat`.  
æ•´æ•°å€¤ã«å¯¾ã—ã¦ `Float` ã‚’ä½¿ç”¨ã—ãŸã„å ´åˆã€å‹è¨˜è¿°å­ã‚’è¿½åŠ ã—ãªã‘ã‚Œã°ã€è‡ªå‹•çš„ã« `ÃŒnt` ã‚„ `Nat` ã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚
```motoko
let f : Float = 2;
let n = 2;  // Automatically casted to type Nat
```

`Float` are implemented on 64-bits folowing the [IEEE 754 representation](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/). Due to the limited precision, operations may result in numerical errors.  
`Float` ã¯ [IEEE 754 representation](https://www.geeksforgeeks.org/ieee-standard-754-floating-point-numbers/) ã«å¾“ã„ã€64ãƒ“ãƒƒãƒˆã§å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚ç²¾åº¦ãŒä½ã„ãŸã‚ã€æ¼”ç®—ã«ã‚ˆã£ã¦ã¯æ•°å€¤èª¤å·®ãŒç”Ÿã˜ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

```motoko
0.1 + 0.1 + 0.1 == 0.3 // => false
```
```motoko
1e16 + 1.0 != 1e16 // => false
```
## ğŸ›ï¸ Bounded types / Bounded å‹
Motoko provides support for bounded types which are integer types with fixed precision. These bounded types can be useful for several reasons:  
Motokoã¯ï¼Œå›ºå®šç²¾åº¦ã®æ•´æ•°å‹ã§ã‚ã‚‹æœ‰ç•Œå‹ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å¢ƒç•Œä»˜ãå‹ã¯ã€ã„ãã¤ã‹ã®ç†ç”±ã§æœ‰ç”¨ã§ã™ï¼š
- Memory efficiency: Bounded types allow you to know exactly how much memory your data will occupy.
- ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãŒè‰¯ã„ï¼š ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ï¼šãƒã‚¦ãƒ³ãƒ‰å‹ã¯ã€ãƒ‡ãƒ¼ã‚¿ãŒå æœ‰ã™ã‚‹ãƒ¡ãƒ¢ãƒªé‡ã‚’æ­£ç¢ºã«æŠŠæ¡ã§ãã¾ã™ã€‚
- Exact sizing: When you know that an API returns an exact number, you can use bounded types to ensure that the - returned number is represented accurately.
- æ­£ç¢ºãªã‚µã‚¤ã‚¸ãƒ³ã‚°ï¼š APIãŒæ­£ç¢ºãªæ•°å€¤ã‚’è¿”ã™ã“ã¨ãŒåˆ†ã‹ã£ã¦ã„ã‚‹å ´åˆã€å¢ƒç•Œå‹ã‚’ä½¿ã£ã¦ã€è¿”ã•ã‚ŒãŸæ•°å€¤ãŒæ­£ç¢ºã«è¡¨ç¾ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã§ãã¾ã™ã€‚
- Execution efficiency: If you know that your numbers require 64-bit arithmetic, using `Nat64` is more efficient than using `Nat`.
- å®Ÿè¡ŒåŠ¹ç‡ï¼š æ•°å€¤ãŒ64ãƒ“ãƒƒãƒˆæ¼”ç®—ã‚’å¿…è¦ã¨ã™ã‚‹ã“ã¨ãŒåˆ†ã‹ã£ã¦ã„ã‚‹å ´åˆã€`Nat`ã‚’ä½¿ã†ã‚ˆã‚Šã‚‚`Nat64`ã‚’ä½¿ã†æ–¹ãŒåŠ¹ç‡çš„ã§ã™ã€‚
- Bitwise arithmetic: Bounded types make it easier to perform bitwise operations such as `<<` or `XOR` on binary data.
- ãƒ“ãƒƒãƒˆå˜ä½ã®æ¼”ç®—ï¼š å¢ƒç•Œå‹ã¯ã€ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã«å¯¾ã—ã¦ `<<` ã‚„ `XOR` ãªã©ã®ãƒ“ãƒƒãƒˆæ¼”ç®—ã‚’ç°¡å˜ã«å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

### Nat8, Nat16, Nat32 and Nat64 / Nat8, Nat16, Nat32 ã¨ Nat64
There are four natural types supported in Motoko: `Nat8`, `Nat16`, `Nat32`, and `Nat64`.  
Motokoã§ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹è‡ªç„¶å‹ã¯ã€`Nat8`, `Nat16`, `Nat32`, `Nat64`ã®4ç¨®é¡ã§ã™ã€‚

The number in the type name specifies the number of bits in the type representation. For example, `Nat32` represents a 32-bit natural number.
å‹åã«å«ã¾ã‚Œã‚‹æ•°å€¤ã¯ã€å‹è¡¨ç¾ã®ãƒ“ãƒƒãƒˆæ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ä¾‹ãˆã°ã€`Nat32`ã¯32ãƒ“ãƒƒãƒˆã®è‡ªç„¶æ•°ã‚’è¡¨ã—ã¾ã™ã€‚

To declare a bounded variable, you must specify the type explicitly to avoid it being automatically cast to a regular `Nat`:  
å¢ƒç•Œä»˜ãå¤‰æ•°ã‚’å®£è¨€ã™ã‚‹ã«ã¯ã€é€šå¸¸ã® `Nat` ã«è‡ªå‹•çš„ã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚Œã‚‹ã®ã‚’é¿ã‘ã‚‹ãŸã‚ã«ã€æ˜ç¤ºçš„ã«å‹ã‚’æŒ‡å®šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š
```motoko
let n : Nat32 = 1;
```
In contrast, if you declare a variable without specifying its type, it will default to a regular `Nat`  
ä¸€æ–¹ã€å‹ã‚’æŒ‡å®šã›ãšã«å¤‰æ•°ã‚’å®£è¨€ã—ãŸå ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§é€šå¸¸ã® `Nat` ã«ãªã‚Šã¾ã™ã€‚
```motoko
let n = 1; // Will be casted to Nat automatically / è‡ªå‹•çš„ã« Nat ã«ã‚­ãƒ£ã‚¹ãƒˆã•ã‚Œã¾ã™ 
```
### Int8, Int16, Int32, and Int64 / Int8, Int16, Int32, ã¨ Int64
Motoko also supports integer types, including `Int8`, `Int16`, `Int32`, and `Int64`. Bounded integer types behave similarly to bounded natural types, except they support negative values. The number in the type name specifies the number of bits in the type representation. For example, `Int32` represents a 32-bit integer:  
Motoko ã¯ `Int8`, `Int16`, `Int32`, `Int64` ãªã©ã®æ•´æ•°å‹ã‚‚ã‚µãƒãƒ¼ãƒˆã—ã¦ã„ã¾ã™ã€‚å¢ƒç•Œä»˜ãæ•´æ•°å‹ã¯ã€è² ã®å€¤ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ã“ã¨ã‚’é™¤ã„ã¦ã€å¢ƒç•Œä»˜ãè‡ªç„¶å‹ã¨åŒæ§˜ã®å‹•ä½œã‚’ã—ã¾ã™ã€‚å‹åã«å«ã¾ã‚Œã‚‹æ•°å€¤ã¯ã€å‹è¡¨ç¾ã®ãƒ“ãƒƒãƒˆæ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚ä¾‹ãˆã°ã€`Int32` ã¯32ãƒ“ãƒƒãƒˆæ•´æ•°ã‚’è¡¨ã—ã¾ã™ï¼š
```motoko
let i : Int32 = -1;
```

## ğŸ¤– Blob.
`Blob` stands for Binary Large Object. The `Blob` type represents an immutable sequence of bytes: they are immutable, iterable, but not indexable and can be empty. <br/>
`Blob`ã¯ Binary Large Object ã®ç•¥ã§ã™ã€‚`Blob`å‹ã¯ã€ãƒã‚¤ãƒˆåˆ—ã‚’è¡¨ã—ã¾ã™ã€‚ã‚¤ãƒŸãƒ¥ãƒ¼ã‚¿ãƒ–ãƒ«ã§åå¾©å¯èƒ½ã§ã‚ã‚‹ãŒã€indexable ã§ã¯ãªãã€ç©ºã§ã‚ã‚‹ã“ã¨ã‚‚ã‚ã‚Šã¾ã™ã€‚<br/>

Byte sequences are also often represented as `[Nat8]`, i.e. an array of bytes, but this representation is currently much less compact than `Blob`, taking 4 physical bytes to represent each logical byte in the sequence.  
ãƒã‚¤ãƒˆåˆ—ã¯ `[Nat8]` ã¤ã¾ã‚Šãƒã‚¤ãƒˆã®é…åˆ—ã¨ã—ã¦è¡¨ç¾ã•ã‚Œã‚‹ã“ã¨ã‚‚å¤šã„ãŒã€ã“ã®è¡¨ç¾ã¯ `Blob` ã‚ˆã‚Šã‚‚ã¯ã‚‹ã‹ã«ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã§ã¯ãªãã€é…åˆ—ã®å„è«–ç†ãƒã‚¤ãƒˆã‚’è¡¨ç¾ã™ã‚‹ã®ã«4ãƒã‚¤ãƒˆã®ç‰©ç†ãƒã‚¤ãƒˆãŒå¿…è¦ã§ã‚ã‚‹ã€‚

If you would like to manipulate Blobs, it is recommended that you convert `Blobs` to `[var Nat8]` or `Buffer<Nat8>`, do the manipulation, then convert back.  
Blob ã‚’æ“ä½œã—ãŸã„å ´åˆã¯ã€`Blobs` ã‚’ `[var Nat8]` ã¾ãŸã¯ `Buffer<Nat8>` ã«å¤‰æ›ã—ã¦æ“ä½œã‚’è¡Œã„ã€ãã‚Œã‹ã‚‰å…ƒã«æˆ»ã™ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚

## ğŸ«™ Unit type / Unit å‹
The last type we will mention in this chapter is the unit type `()`. This type is also called the empty tuple type. It's useful in several places, for example in functions to indicate that a function does not return any specific type.  
ã“ã®ç« ã§æœ€å¾Œã«ç´¹ä»‹ã™ã‚‹ã®ã¯ã€unit å‹ `()` ã§ã™ã€‚ã“ã®å‹ã¯ç©ºã‚¿ãƒ—ãƒ«å‹ã¨ã‚‚å‘¼ã°ã‚Œã¾ã™ã€‚ã“ã®å‹ã¯ã„ãã¤ã‹ã®å ´æ‰€ã§æœ‰ç”¨ã§ã‚ã‚Šï¼Œä¾‹ãˆã°ï¼Œé–¢æ•°ã®ä¸­ã§ï¼Œã‚ã‚‹é–¢æ•°ãŒç‰¹å®šã®å‹ã‚’è¿”ã•ãªã„ã“ã¨ã‚’ç¤ºã™ã®ã«ä½¿ã‚ã‚Œã¾ã™ã€‚
```motoko
import Debug "mo:base/Debug";
actor {
    public func printMessage(message : Text) : async () {
        Debug.print(message);
        return();
    };
}
```
