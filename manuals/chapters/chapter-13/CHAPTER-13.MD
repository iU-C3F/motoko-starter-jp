# Chapter 13: Playing with time in Motoko. / ç¬¬13ç«  Motoko ã§æ™‚é–“ã§éŠã¶ã€‚
## ğŸ•£ Time
A challenge that comes with a distributed system such as the Internet Computer is the notion of time. Each node has it's own internal horloge. To respected determinisn, the time provided to the canister is the **system time** - a value agreed upon by the subnet. The **system time** is represented as nanoseconds since 1970-01-01.  
Internet Computer ã®ã‚ˆã†ãªåˆ†æ•£å‹ã‚·ã‚¹ãƒ†ãƒ ã§èª²é¡Œã¨ãªã‚‹ã®ã¯ã€æ™‚é–“ã®æ¦‚å¿µã§ã™ã€‚å„ãƒãƒ¼ãƒ‰ã«ã¯ç‹¬è‡ªã®å†…éƒ¨æ™‚è¨ˆãŒã‚ã‚Šã¾ã™ã€‚ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«æä¾›ã•ã‚Œã‚‹æ™‚é–“ã¯ã€ã‚µãƒ–ãƒãƒƒãƒˆã§åˆæ„ã•ã‚ŒãŸå€¤ã§ã‚ã‚‹ **ã‚·ã‚¹ãƒ†ãƒ æ™‚é–“** ã§ã‚ã‚‹ã“ã¨ã‚’å°Šé‡ã—ã¾ã™ã€‚**ã‚·ã‚¹ãƒ†ãƒ æ™‚é–“** ã¯ã€1970-01-01 ã‹ã‚‰ã®ãƒŠãƒç§’ã¨ã—ã¦è¡¨ã•ã‚Œã¾ã™ã€‚

In Motoko, the type `Time` is an aliast for `Int`.  
Motoko ã§ã¯ã€`Time` ã¨ã„ã†å‹ã¯ `Int` ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã§ã™ã€‚
```motoko
public type Time = Int;
```
The Time module gives us access to the `now()` function that returns the system time.  
Time ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯ã€ã‚·ã‚¹ãƒ†ãƒ æ™‚åˆ»ã‚’è¿”ã™ `now()` é–¢æ•°ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚  
```motoko
import Time "mo:base/Time";
actor {
    public type Time = Time.Time;
    public func whatTimeIsIt() : async Time.Time {
        Time.now();
    };
};
```

The time returned by `Time.now()` is constant within a message execution.  
`Time.now()` ãŒè¿”ã™æ™‚åˆ»ã¯ã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å®Ÿè¡Œç¯„å›²å†…ã§ä¸€å®šã§ã™ã€‚
```motoko
import Time "mo:base/Time";
import Debug "mo:base/Debug";
actor {
    public type Time = Time.Time;

    func doSomething() :  () {
        Debug.print("Doing some work");
    };

    public func whatTimeIsIt() : async (Time, Time) {
        let a = Time.now();
        doSomething();
        let b = Time.now();
        return (a, b);
    };
};
```
The value of `a` and `b` will be the same. Try it out [here](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=4264079271).  
`a` ã¨ `b` ã®å€¤ã¯åŒã˜ã«ãªã‚Šã¾ã™ã€‚è©¦ã—ã« [ã“ã¡ã‚‰](https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=4264079271) ã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„ã€‚
## â° Timer / ã‚¿ã‚¤ãƒãƒ¼
Sometimes you need to run tasks a on regular basic (every minute/hour/day...). To run cronic tasks, you can use the [Timer library](https://internetcomputer.org/docs/current/motoko/main/base/Timer).  
å®šæœŸçš„ã«ï¼ˆ1åˆ†æ¯ã€1æ™‚é–“æ¯ã€1æ—¥æ¯...ï¼‰ã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚å®šæœŸçš„ãªã‚¿ã‚¹ã‚¯ã®å®Ÿè¡Œã«ã¯ã€[Timer library](https://internetcomputer.org/docs/current/motoko/main/base/Timer) ã‚’åˆ©ç”¨ã§ãã¾ã™ã€‚

This library defines two types:  
æœ¬ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã€2ã¤ã®ã‚¿ã‚¤ãƒ—ã‚’å®šç¾©ã—ã¦ã„ã¾ã™ï¼š
1. `Duration` represents a delay before executing the job. The delay provided can be as small as possible but the resolution cannot be faster than the block rate.  
`Duration` ã¯ã€ã‚¸ãƒ§ãƒ–ã‚’å®Ÿè¡Œã™ã‚‹ã¾ã§ã®é…å»¶ã‚’è¡¨ã—ã¾ã™ã€‚æä¾›ã•ã‚Œã‚‹é…å»¶ã¯å¯èƒ½ãªé™ã‚Šå°ã•ãã™ã‚‹ã“ã¨ã¯ã§ãã¾ã™ãŒã€ãƒ–ãƒ­ãƒƒã‚¯ãƒ¬ãƒ¼ãƒˆã‚ˆã‚Šé€Ÿãã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã€‚
```motoko
type Duration = {#seconds : Nat; #nanoseconds : Nat}
```
2. `TimerId` is an ID to identify the timer.  
`TimerId` ã¯ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã® ID ã§ã™ã€‚
```motoko
type TimerId = Nat
```

This library exposes different methods:  
ã“ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ã¯ã€ã•ã¾ã–ã¾ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å…¬é–‹ã—ã¦ã„ã¾ã™ï¼š
- `setTimer` allows  you to set a `job` that will be executed once in the future after the given duration `d` has passed.
- `setTimer` ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæ™‚é–“ `d` ãŒçµŒéã—ãŸå¾Œã«ã€å°†æ¥ä¸€åº¦ã ã‘å®Ÿè¡Œã•ã‚Œã‚‹ `job` ã‚’è¨­å®šã§ãã¾ã™ã€‚
```motoko
func setTimer(d : Duration, job : () -> async ()) : TimerId
```
```motoko
let oneHourInSeconds = 60 * 60;
func endExam() : async () {
    Debug.print("ğŸ”š")
};
let id = setTimer(#seconds(oneHourInSeconds), endExam);
```

- `recurringTimer` allows you to set a `job` that will be executed chronically everytime the given duration `d` has passed. 
- `recurringTimer` ã¯ã€ä¸ãˆã‚‰ã‚ŒãŸæœŸé–“ `d` ãŒçµŒéã™ã‚‹ãŸã³ã«ç¶™ç¶šçš„ã«å®Ÿè¡Œã•ã‚Œã‚‹ `job` ã‚’è¨­å®šã§ãã¾ã™ã€‚
```motoko
func recurringTimer(d : Duration, job : () -> async ()) : TimerId
```
```motoko
let oneDayInSeconds = 60 * 60 * 24;
func study() : async () {
    Debug.print("ğŸ™‡")
};
let studyId = reccuringTimer(#seconds(oneDayInSeconds), study);
```
- `cancelTimer` will cancel an active timer. If the `id` provided is not recognized nothing happens.
- `cancelTimer` ã¯ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™ã€‚æŒ‡å®šã•ã‚ŒãŸ `id` ãŒèªè­˜ã•ã‚Œãªã„å ´åˆã¯ã€ä½•ã‚‚èµ·ã“ã‚Šã¾ã›ã‚“ã€‚
```motoko
let cancelTimer : TimerId -> ()
```
```motoko
func quitSchool() {
    cancelTimer(studyId);
};
```
## ğŸ«€ Heartbeat / ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆ
A canister can exposes a system function `heartbeat`. 
This function is automatically triggered by the protocol at every round of execution, approximately every second.  
ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€ã‚·ã‚¹ãƒ†ãƒ é–¢æ•° `heartbeat` ã‚’å…¬é–‹ã§ãã¾ã™ã€‚ã“ã®é–¢æ•°ã¯ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å®Ÿè¡Œãƒ©ã‚¦ãƒ³ãƒ‰ã”ã¨ã«ã€ãŠã‚ˆãï¼‘ç§’ã”ã¨ã«è‡ªå‹•çš„ã«ãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã¾ã™ã€‚

```motoko
import Debug "mo:base/Debug";
import Time "mo:base/Time";
actor {

    public type Time = Time.Time;

    var count : Nat = 0;
    var times : [Time] = [] 

    system func heartbeat() : async () {
        count += 1;
        if(count % 100 == 0) {
            // Every 10O invocations of the heartbeat function.
            times := Array.append<Time>(times, [Time.now()]);
        } 
    };
}
```

> The **heartbeat** functionality is being replace by **timers** due to prohibitive costs.

> **ãƒãƒ¼ãƒˆãƒ“ãƒ¼ãƒˆ** æ©Ÿèƒ½ã¯ã€æ³•å¤–ãªã‚³ã‚¹ãƒˆã®ãŸã‚ã€**ã‚¿ã‚¤ãƒãƒ¼** ã«ç½®ãæ›ãˆã‚‰ã‚Œã¦ã„ã¾ã™ã€‚