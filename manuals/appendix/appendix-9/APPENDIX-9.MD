# Appendix 9: HTTP Request to access a canister through a browser. / ä»˜éŒ²9ï¼šãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã®HTTPãƒªã‚¯ã‚¨ã‚¹ãƒˆã€‚
## Difference between HTTP request & HTTP outcalls. / HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¨ HTTP ã‚¢ã‚¦ãƒˆã‚³ãƒ¼ãƒ«ã®é•ã„ã€‚
In this chapter, we will cover how canisters can be accessed through HTTP requests. This is a separate topic from **HTTP Outcalls**:  
ã“ã®ç« ã§ã¯ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’ HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã«ã¤ã„ã¦èª¬æ˜ã—ã¾ã™ã€‚ã“ã‚Œã¯ **HTTP Outcalls** ã¨ã¯åˆ¥ã®ãƒˆãƒ”ãƒƒã‚¯ã§ã™ï¼š

- HTTP Request: Canisters can handle incoming requests and serve web pages.  
- HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼š ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€å—ä¿¡ã—ãŸãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ã€ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸ã‚’æä¾›ã§ãã¾ã™ã€‚
- HTTP Outcalls: Canisters can send requests and communicate with the Web 2.0 world. This can be used for various use cases, such as querying an exchange for token prices, getting the latest weather information, and sending notifications to users.
- HTTP ã‚¢ã‚¦ãƒˆã‚³ãƒ¼ãƒ«ï¼š ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã—ã€Web 2.0 ãƒ¯ãƒ¼ãƒ«ãƒ‰ã¨é€šä¿¡ã§ãã¾ã™ã€‚ãƒˆãƒ¼ã‚¯ãƒ³ã®ä¾¡æ ¼ã‚’å–å¼•æ‰€ã«å•ã„åˆã‚ã›ãŸã‚Šã€æœ€æ–°ã®æ°—è±¡æƒ…å ±ã‚’å–å¾—ã—ãŸã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ã‚’é€ã£ãŸã‚Šã¨ã€ã•ã¾ã–ã¾ãªãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«åˆ©ç”¨ã§ãã¾ã™ã€‚

Whenever you [access a canister](https://wujxq-qqaaa-aaaaj-qazca-cai.raw.ic0.app/) through your browser there are a few steps involved. Let's go through all of them.
You will notice that URLs on the Internet Computer are of the following form: <CANISTER_ID>.ic0.app The .ic0.app indicates that you are reaching out to [boundary nodes]().  
ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ [ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹](https://wujxq-qqaaa-aaaaj-qazca-cai.raw.ic0.app/) ã™ã‚‹å ´åˆã€å¿…ãšã„ãã¤ã‹ã®æ‰‹é †ãŒã‚ã‚Šã¾ã™ã€‚ã“ã“ã§ã¯ã€ãã®ã™ã¹ã¦ã‚’èª¬æ˜ã—ã¾ã™ã€‚
Internet Computer ã®URLã¯ã€æ¬¡ã®ã‚ˆã†ãªå½¢ã«ãªã£ã¦ã„ã‚‹ã“ã¨ã«ãŠæ°—ã¥ãã§ã—ã‚‡ã†ã‹ï¼š <CANISTER_ID>.ic0.app .ic0.appã¯ã€ã‚ãªãŸãŒ[ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰]()ã«åˆ°é”ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¤ºã—ã¾ã™ã€‚

## What are boundary nodes? / ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã¨ã¯ä½•ã§ã™ã‹ï¼Ÿ
Canisters are hosted and executed by nodes that participate in the IC consensus However, those nodes are not directly accessible by end users.
To protect the consensus nodes & improve performance there is a layer of boundary nodes which serve different useful purposes:  
ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã€IC ã‚³ãƒ³ã‚»ãƒ³ã‚µã‚¹ã«å‚åŠ ã™ã‚‹ãƒãƒ¼ãƒ‰ã«ã‚ˆã£ã¦ãƒ›ã‚¹ãƒˆã•ã‚Œå®Ÿè¡Œã•ã‚Œã¾ã™ã€‚ã—ã‹ã—ã€ã“ã‚Œã‚‰ã®ãƒãƒ¼ãƒ‰ã¯ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç›´æ¥ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ã‘ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ã‚³ãƒ³ã‚»ãƒ³ã‚µã‚¹ãƒãƒ¼ãƒ‰ã‚’ä¿è­·ã—ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å‘ä¸Šã•ã›ã‚‹ãŸã‚ã«ã€ç•°ãªã‚‹æœ‰ç”¨ãªç›®çš„ã‚’æŒã¤ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã®å±¤ãŒå­˜åœ¨ã—ã¾ã™ï¼š

- Translate the HTTP request of the user's browser to canister call. This part is called the HTTP Gateway protocol. When canisters send their response the gateway will convert it back to an HTTP request.
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ–ãƒ©ã‚¦ã‚¶ã® HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚³ãƒ¼ãƒ«ã«å¤‰æ›ã—ã¾ã™ã€‚ã“ã®éƒ¨åˆ†ã‚’ HTTP ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã¨å‘¼ã³ã¾ã™ã€‚ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒå¿œç­”ã‚’é€ä¿¡ã™ã‚‹ã¨ã€ã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤ã¯ãã‚Œã‚’ HTTP ãƒªã‚¯ã‚¨ã‚¹ãƒˆã«å¤‰æ›ã—ã¾ã™ã€‚
- Route the calls to the correct subnet running the canister. To properly route those calls the boundary nodes have to keep track of the entire configuration of the Internet Computer:
- å‘¼ã³å‡ºã—ã‚’ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹æ­£ã—ã„ã‚µãƒ–ãƒãƒƒãƒˆã«ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã—ã¾ã™ã€‚ã“ã‚Œã‚‰ã®å‘¼ã³å‡ºã—ã‚’é©åˆ‡ã«ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã™ã‚‹ãŸã‚ã«ã€ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã¯ Internet Computer ã®å…¨æ§‹æˆã‚’æŠŠæ¡ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ï¼š
    - List of subnets.
    - ã‚µãƒ–ãƒãƒƒãƒˆã®ãƒªã‚¹ãƒˆã€‚
    - List of nodes and which subnet they belong to.
    - ãƒãƒ¼ãƒ‰ã®ãƒªã‚¹ãƒˆã¨ã€ãã‚Œã‚‰ãŒã©ã®ã‚µãƒ–ãƒãƒƒãƒˆã«å±ã—ã¦ã„ã‚‹ã‹ã€‚
    - The canisters run by each subnet.
    - å„ã‚µãƒ–ãƒãƒƒãƒˆã§å®Ÿè¡Œã•ã‚Œã‚‹ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã€‚
- Load balancing among the subnet's replica nodes (i.e if a replica is lagging behind and has already a lot of work on its plate - boundary nodes will send the request to another replica).
- ã‚µãƒ–ãƒãƒƒãƒˆã®ãƒ¬ãƒ—ãƒªã‚«ãƒãƒ¼ãƒ‰é–“ã®ãƒ­ãƒ¼ãƒ‰ãƒãƒ©ãƒ³ã‚·ãƒ³ã‚°ï¼ˆã‚ã‚‹ãƒ¬ãƒ—ãƒªã‚«ãŒé…ã‚Œã¦ã„ã¦ã€ã™ã§ã«å¤šãã®ä»•äº‹ã‚’æŠ±ãˆã¦ã„ã‚‹å ´åˆã€ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã¯åˆ¥ã®ãƒ¬ãƒ—ãƒªã‚«ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ã‚Šã¾ã™ï¼‰ã€‚
- Protect subnets from DDoS attacks.
- DDoS æ”»æ’ƒã‹ã‚‰ã‚µãƒ–ãƒãƒƒãƒˆã‚’ä¿è­·ã—ã¾ã™ã€‚

<p align="center"> <img src="./img/http_gateway.png" width="800px" style="border: 2px solid black;"> </p>

> Currently, boundary nodes are run by the DFINITY Foundation. However, the objective ([as part of the roadmap](https://forum.dfinity.org/t/boundary-node-roadmap/15562)) is to have anyone able to set up and run a boundary nodes. This will make interaction with the Internet Computer more reactive for end users and this will make the platform more robust to censorship.

> ç¾åœ¨ã€ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã¯ DFINITY Foundation ã«ã‚ˆã£ã¦é‹å–¶ã•ã‚Œã¦ã„ã¾ã™ã€‚ã—ã‹ã—ã€ç›®æ¨™ï¼ˆ[ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã®ä¸€éƒ¨ã¨ã—ã¦](https://forum.dfinity.org/t/boundary-node-roadmap/15562)ï¼‰ã¯ã€èª°ã§ã‚‚ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã—ã¦å®Ÿè¡Œã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã“ã¨ã§ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¨ãƒ³ãƒ‰ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦ Internet Computer ã¨ã®ç›¸äº’ä½œç”¨ãŒçŠ¶æ³ã®å¤‰åŒ–ã«ã‚ˆã‚Šå¯¾å¿œã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã€æ¤œé–²ã«å¯¾ã—ã¦ã‚ˆã‚Šå¼·å›ºãªãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ ã¨ãªã‚‹ã“ã¨ã§ã—ã‚‡ã†ã€‚

## Asset canister / ã‚¢ã‚»ãƒƒãƒˆã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼
To serve web content on the Internet Computer, a canister should have a method that can handle an `http_request`, which includes the URL, HTTP method, and headers, and produce an HTTP response, consisting of a status, headers, and body. There are two ways to go about that:  
Internet Computer ä¸Šã« Web ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’æä¾›ã™ã‚‹ãŸã‚ã«ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ URLã€HTTP ãƒ¡ã‚½ãƒƒãƒ‰ã€ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã‚€ `http_request` ã‚’å‡¦ç†ã—ã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€ãƒ˜ãƒƒãƒ€ãƒ¼ã€ãƒœãƒ‡ã‚£ã‹ã‚‰ãªã‚‹ HTTP ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ç”Ÿæˆã§ãã‚‹ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ãã‚Œã«ã¯ã€ï¼’ã¤ã®æ–¹æ³•ãŒã‚ãƒªã¾ã™ï¼š

- Implement the http_request method and all associated logic yourself.  
- http_request ãƒ¡ã‚½ãƒƒãƒ‰ã¨é–¢é€£ã™ã‚‹ã™ã¹ã¦ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’è‡ªåˆ†ã§å®Ÿè£…ã™ã‚‹ã€‚ 
- Use the provided **asset** canister: this is a special canister whose code has been already implemented by DFINITY. You need to specify the type of this canister in `dfx.json` & add the source folder of your web app. Once the asset canister is deployed on the Internet Computer the website can be accessed at `http://<canister id>.ic0.app` and `http://<canister id>.raw.ic0.app`. The frontend canister that is shipped when you deploy a project with `dfx new <project>` is an asset canister (as you can confirm by looking at `dfx.json`).
- æä¾›ã•ã‚ŒãŸ **asset** ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹: ã“ã‚Œã¯ã€DFINITY ã«ã‚ˆã£ã¦ã‚³ãƒ¼ãƒ‰ãŒæ—¢ã«å®Ÿè£…ã•ã‚Œã¦ã„ã‚‹ç‰¹åˆ¥ãªã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã§ã™ã€‚ã“ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ç¨®é¡ã‚’ `dfx.json` ã§æŒ‡å®šã—ã€Web ã‚¢ãƒ—ãƒªã®ã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã«è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚ã‚¢ã‚»ãƒƒãƒˆã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒ Internet Computer ä¸Šã«é…ç½®ã•ã‚Œã‚‹ã¨ã€ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã¯ `http://<canister id>.ic0.app` ã¨ `http://<canister id>.raw.ic0.app` ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚`dfx new <project>` ã‚’ä½¿ç”¨ã—ã¦ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹æ™‚ã«åŒæ¢±ã•ã‚Œã‚‹ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã¯ã‚¢ã‚»ãƒƒãƒˆã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã§ã™ï¼ˆ`dfx.json` ã‚’è¦‹ã‚Œã°ç¢ºèªã§ãã¾ã™ï¼‰ã€‚

> You can access [the source code for this canister written in Rust](https://github.com/dfinity/sdk/tree/master/src/canisters/frontend/ic-frontend-canister) under the [DFINITY organization](https://github.com/dfinity).  

> [Rustã§æ›¸ã‹ã‚ŒãŸã“ã®ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰](https://github.com/dfinity/sdk/tree/master/src/canisters/frontend/ic-frontend-canister) ã¯ã€[DFINITY Foundation](https://github.com/dfinity) ã®ä¸‹ã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã™ã€‚ 

## Difference between ic0.app & raw.ic0.app / ic0.app ã¨ raw.ic0.app ã®ç›¸é•ç‚¹
As we've said earlier there are two ways to access a canister:  
å…ˆã«è¿°ã¹ãŸã‚ˆã†ã«ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹æ–¹æ³•ã¯ï¼’ã¤ã‚ã‚Šã¾ã™ï¼š
- raw.ic0.app: the raw URL raw URL will simply return the request as it is so serves the asset files (HTML, CSS, Javascript).
- raw.ic0.app: raw URL ã¯ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãã®ã¾ã¾è¿”ã™ã ã‘ãªã®ã§ã€ã‚¢ã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆHTMLã€CSSã€Javascriptï¼‰ã‚’æä¾›ã—ã¾ã™ã€‚
- ic0.app: uses a service worker to verify the content served by the boundary node. The service worker is loaded and then handles requests, verifying the signature of the assets served by the canister using the public key on the Internet Computer.
- ic0.appï¼šãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ãŒæä¾›ã™ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ç¢ºèªã™ã‚‹ãŸã‚ã«ã€ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã¯ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸå¾Œã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å‡¦ç†ã—ã€Internet Computer ä¸Šã®å…¬é–‹éµã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ãŒæä¾›ã™ã‚‹ã‚¢ã‚»ãƒƒãƒˆã®ç½²åã‚’æ¤œè¨¼ã—ã¾ã™ã€‚

<p align="center"> <img src="./img/service_worker.png" width="800px" style="border: 2px solid black;"> </p>
<p align="center"> Loading the service worker...</p>

When accessing a webpage, speed is a key factor. This is why we use query calls to handle http_request. However, it's important to note that query calls do not go through a consensus process and cannot create signatures. To address this issue, we use certified variables. This means that the content must be certified prior to the call being made. In some cases, this certification process may not be possible and if you are accessing a website under ic0.app, you may encounter an error page as a result.

ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ãã€ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯é‡è¦ãªè¦ç´ ã§ã™ã€‚ãã®ãŸã‚ã€http_request ã®å‡¦ç†ã«ã‚¯ã‚¨ãƒªãƒ¼ã‚³ãƒ¼ãƒ«ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚ãŸã ã—ã€ã‚¯ã‚¨ãƒªãƒ¼ã‚³ãƒ¼ãƒ«ã¯åˆæ„å½¢æˆãƒ—ãƒ­ã‚»ã‚¹ã‚’çµŒãªã„ãŸã‚ã€ç½²åã‚’ä½œæˆã§ããªã„ã“ã¨ã«æ³¨æ„ãŒå¿…è¦ã§ã™ã€‚ã“ã®å•é¡Œã«å¯¾å‡¦ã™ã‚‹ãŸã‚ã€ç§ãŸã¡ã¯èªè¨¼æ¸ˆã¿å¤‰æ•°ã‚’ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚ã¤ã¾ã‚Šã€å‘¼ã³å‡ºã—ãŒè¡Œã‚ã‚Œã‚‹å‰ã«ã€ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®èªè¨¼ãŒå¿…è¦ãªã®ã§ã™ã€‚å ´åˆã«ã‚ˆã£ã¦ã¯ã€ã“ã®èªè¨¼ãƒ—ãƒ­ã‚»ã‚¹ãŒã§ããªã„ã“ã¨ã‚‚ã‚ã‚Šã€ic0.app ã®ä¸‹ã§ã‚¦ã‚§ãƒ–ã‚µã‚¤ãƒˆã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å ´åˆã€çµæœã¨ã—ã¦ã‚¨ãƒ©ãƒ¼ãƒšãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚

<p align="center"> <img src="./img/body_no_verification.png" width="800px" style="border: 2px solid black;"> </p>

<p align="center" > In that case you should access under raw.ic0.app to avoid the issue.  
ãã®å ´åˆã€raw.ic0.app ã§ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ã§å•é¡Œã‚’å›é¿ã§ãã¾ã™ã€‚</p>

> It's worth noting that the service worker received when accessing ic0.app could potentially be altered by the boundary node to certify incorrect responses. This is a potential issue since most users won't take the time to verify the authenticity of the service worker. To mitigate this risk, it would be ideal to have the public key of the Internet Computer directly integrated into the hardware or browser! This would provide an expectional level of security and be a convenient option, giving users peace of mind and the confidence to trust the authenticity of the content they are accessing!"

> ic0.app ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãŸã¨ãã«å—ã‘å–ã£ãŸã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒã€ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ã«ã‚ˆã£ã¦ä¸æ­£ãªå¿œç­”ã‚’è¨¼æ˜ã™ã‚‹ãŸã‚ã«å¤‰æ›´ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã“ã¨ã¯æ³¨ç›®ã«å€¤ã—ã¾ã™ã€‚ã“ã‚Œã¯ã€ã»ã¨ã‚“ã©ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã®ä¿¡é ¼æ€§ã‚’ç¢ºèªã™ã‚‹æ™‚é–“ã‚’å–ã‚‰ãªã„ãŸã‚ã€æ½œåœ¨çš„ãªå•é¡Œã§ã™ã€‚ã“ã®ãƒªã‚¹ã‚¯ã‚’è»½æ¸›ã™ã‚‹ãŸã‚ã«ã¯ã€Internet Computer ã®å…¬é–‹éµã‚’ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚„ãƒ–ãƒ©ã‚¦ã‚¶ã«ç›´æ¥çµ„ã¿è¾¼ã‚€ã“ã¨ãŒç†æƒ³çš„ã§ã™ï¼ã“ã‚Œã«ã‚ˆã‚Šã€æœŸå¾…ã•ã‚Œã‚‹ãƒ¬ãƒ™ãƒ«ã®ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãŒæä¾›ã•ã‚Œã€ä¾¿åˆ©ãªã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¨ãªã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å®‰å¿ƒæ„Ÿã‚’ä¸ãˆã€ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã‚‹ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®çœŸæ­£æ€§ã‚’ä¿¡é ¼ã™ã‚‹è‡ªä¿¡ã‚’ä¸ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ï¼"

## ğŸ¤™ Contacting the canister / ğŸ¤™ ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã«ã‚³ãƒ³ã‚¿ã‚¯ãƒˆ
Once the boundary node has received the request. It will encode it into Candid and automatically call the http_request method of the canister. reachable by browsers, you need to implement an `http_request` method as part of the public interface of your  actor.  
ãƒã‚¦ãƒ³ãƒ€ãƒªãƒ¼ãƒãƒ¼ãƒ‰ãŒãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ä¿¡ã™ã‚‹ã¨ã€ãã‚Œã‚’ Candid ã«ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã—ã¦ã€ã‚­ãƒ£ãƒ‹ã‚¹ã‚¿ãƒ¼ã® http_request ãƒ¡ã‚½ãƒƒãƒ‰ã‚’è‡ªå‹•çš„ã«å‘¼ã³å‡ºã—ã¾ã™ã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹ã«ã¯ã€ã‚¢ã‚¯ã‚¿ãƒ¼ã®ãƒ‘ãƒ–ãƒªãƒƒã‚¯ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ä¸€éƒ¨ã¨ã—ã¦`http_request`ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚<br/>

This is the minimum code needed to return a simple page that prints **Hello world**.  
ã“ã‚Œã¯ã€**Hello world** ã‚’ãƒ—ãƒªãƒ³ãƒˆã™ã‚‹ã‚·ãƒ³ãƒ—ãƒ«ãªãƒšãƒ¼ã‚¸ã‚’è¿”ã™ãŸã‚ã«å¿…è¦ãªæœ€å°é™ã®ã‚³ãƒ¼ãƒ‰ã§ã™ã€‚
```motoko 
import Text "mo:base/Text";
import Http "http";
actor {
    public type HttpRequest = Http.HttpRequest;
    public type HttpResponse = Http.HttpResponse;

    public query func http_request(req : HttpRequest) : async HttpResponse {
        return({
            body = Text.encodeUtf8("Hello World");
            headers = [];
            status_code = 200;
            streaming_strategy = null;
        });
    };
};
```
Here is the content of the `HTTP` module, the file name is `http.mo`.  
ä»¥ä¸‹ã¯ `HTTP` ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã®å†…å®¹ã§ã‚ã‚Šã€ãƒ•ã‚¡ã‚¤ãƒ«åã¯ `http.mo` ã§ã™ã€‚
```motoko
module Http {
    public type HeaderField = (Text, Text);

    public type HttpRequest = {
        body: Blob;
        headers: [HeaderField];
        method: Text;
        url: Text;
    };

    public type HttpResponse = {
        body: Blob;
        headers: [HeaderField];
        status_code: Nat16;
        streaming_strategy: ?StreamingStrategy;
    };

    public type StreamingStrategy = {
        #Callback: {
            callback : StreamingCallback;
            token    : StreamingCallbackToken;
        };
    };

    public type StreamingCallback = query (StreamingCallbackToken) -> async (StreamingCallbackResponse);

    public type StreamingCallbackToken =  {
        content_encoding : Text;
        index            : Nat;
        key              : Text;
    };

    public type StreamingCallbackResponse = {
        body  : Blob;
        token : ?StreamingCallbackToken;
    };
}
```